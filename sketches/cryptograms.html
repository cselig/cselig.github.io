<!DOCTYPE html><html><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><title>cselig</title><link rel="icon" href="favicon.ico"/><meta name="next-head-count" content="4"/><link rel="preload" href="/_next/static/css/62ae7adc418c4fa89ac0.css" as="style"/><link rel="stylesheet" href="/_next/static/css/62ae7adc418c4fa89ac0.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b3c25108c77d22e4bb58.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b3c25108c77d22e4bb58.css" data-n-p=""/><noscript data-n-css=""></noscript><link rel="preload" href="/_next/static/chunks/main-70acde2203962b3dc5d4.js" as="script"/><link rel="preload" href="/_next/static/chunks/webpack-50d38cb9c3dd5374e2a2.js" as="script"/><link rel="preload" href="/_next/static/chunks/framework.0a4392dc64510ab178c1.js" as="script"/><link rel="preload" href="/_next/static/chunks/commons.6d3bde474c27debf47e2.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/_app-1018bc17b6123053b3bf.js" as="script"/><link rel="preload" href="/_next/static/chunks/fe66c3e56503ac18952228a608ca3464c3766972.02ceb7646fd5a00b4908.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/sketches/%5Bid%5D-efff1a0c2435fd0b2b31.js" as="script"/></head><body><div id="__next"><div class="layout_container__3H2Qg"><svg class="MuiSvgIcon-root layout_back_button__-f7Kp" focusable="false" viewBox="0 0 24 24" aria-hidden="true"><path d="M20 11H7.83l5.59-5.59L12 4l-8 8 8 8 1.41-1.41L7.83 13H20v-2z"></path></svg><h1 class="sketch_title__2-Xm5">Solving Cryptograms</h1><div><style>
.cryptogram, .solution {
  display: flex;
  justify-content: center;
}

.cryptogram > p, .solution > p {
    font-family: Courier, monospace;
    margin: 0;
}

.solution > p, .solution > ul {
  background-color: black;
}

.solution > p:hover, .solution > ul:hover {
  background-color: inherit;
}
</style>
<p>For Christmas my dad gave me a book of cryptograms. While I thought it would be fun to do these by hand,
I thought it would also be fun to write a program to solve them.</p>
<h2>Cryptograms</h2>
<p>Every puzzle in the book uses a substitution cipher where every letter in the decoded space is represented
by another letter in the encoded space. An example puzzle would be:</p>
<div class="cryptogram"><p>APPF VIBQ KMF EKLC DIM!</p></div>
<p>You can try solving it for yourself, or you can hover over the solution below.</p>
<div class="solution"><p>GOOD LUCK AND HAVE FUN!</p></div>
<p>The cipher (the map from encoded to decoded characters) is what the program solves for. The cipher
for the above puzzle is:</p>
<pre><code>a => g, p => o, f => d, v => l, i => u, b => c, q => k, k => a, e => h, l => v, c => e, d => f, m => n
</code></pre>
<h2>The Algorithm</h2>
<p>The main part of the program is a brute force search that recurses through all possible word combinations and looks for
reasonable solutions. However just a naive brute force search would be very slow; it would have nothing to narrow down
the possibilities with.</p>
<p>There needs to be another part of the program that makes some educated guesses. For this
I used some simple intuitions about the English language that humans would use when solving a cryptogram (and that would
be easy to code). Examples of these intuitions include:</p>
<ul>
<li>A single letter word is almost always "I" or "a".</li>
<li>Words containing apostrophes are probably contractions, which there are a relatively small number of.</li>
<li>The solution will probably follow an expected distribution of letters, starting letters, double letters, etc.</li>
</ul>
<p>The program uses a list of English words to solve the cipher. It works by guessing a word and doing a recursive
search with the new cipher that comes from that word. For example, consider the earlier cryptogram and a partially
completed solution:</p>
<div class="cryptogram"><p>APPF VIBQ KMF EKLC DIM!</p></div>
<div class="cryptogram"><p>-OOD ---- --D ---- ---!</p></div>
<p>We know all but the first letter of the first word, so we can "guess and check" by plugging in all words in the dictionary that match
the pattern "-OOD" (good, hood, wood, etc.). After plugging in a word we have a new cipher that includes the letter that
was previously encoded. We can recurse with this new cipher and try to guess other words until we find a solution (or not).</p>
<h2>Indexing</h2>
<p>To do the pattern matching described above, I needed a quick way to look up words that match a certain pattern. I did
this by preprocessing the dictionary and keeping an index of character ngrams (I used 1, 2, and 3-grams).</p>
<pre><code class="language-py"># Ngrams is a dictionary of the triple (ngram, len, i) mapped to a set of
# words of length `len` where the character ngram `ngram` appears at index `i`.
# By including the word length and index in the key we can narrow down word matches.
ngrams: 'Dict[Tuple[str, int, int], Set[str]]' = defaultdict(set)

# words_by_length is a dictionary of length to set of words with that length.
words_by_length: 'Dict[int, Set[str]]' = defaultdict(set)

for word in dictionary:
    words_by_length[len(word)].add(word)
    for i in range(0, len(word)):
        ngrams[(word[i], len(word), i)].add(word)
        if i &#x3C; len(word) - 1:
            ngrams[(word[i:i+2], len(word), i)].add(word)
        if i &#x3C; len(word) - 2:
            ngrams[(word[i:i+3], len(word), i)].add(word)
</code></pre>
<p>The code to do the pattern matching looks at each decoded ngram in the word, gets the set of words associated with that
ngram, and returns the intersection of the sets. For example, to pattern match the word "ap-le", we would would find the set of
words that have length 5 with "ap" appearing at index 0 and intersect it with the set of words of length 5 that have "le" appearing
at index 3. If the word is completely encoded, the best we can do is return the set of words with the same length.
Caching the results of this function is useful since it gets called with the same arguments many times.</p>
<pre><code class="language-py">@lru_cache(maxsize=None)
def find_words_matching_pattern(template: str) -> 'Set[str]':
    # Given a pattern, return words from dictionary that match. "-" is a wildcard.
    # E.g. "-ood" -> {"good", "hood", ...}
    if template.isalpha():
        return set([template])

    ngram_word_matches: 'List[set]' = []
    # look for decoded ngrams
    for i in range(0, len(template)):
        if template[i].isalpha():
            ngram_word_matches.append(ngrams[(template[i], len(template), i)])
        if i &#x3C; len(template) - 1 and template[i:i+2].isalpha():
            ngram_word_matches.append(ngrams[(template[i:i+2], len(template), i)])
        if i &#x3C; len(template) - 2 and template[i:i+3].isalpha():
            ngram_word_matches.append(ngrams[(template[i:i+3], len(template), i)])

    ngram_word_matches = [s for s in ngram_word_matches if len(s) > 0]
    if ngram_word_matches:
        return reduce(lambda a, b: a &#x26; b, ngram_word_matches)
    else:
        return words_by_length[len(template)]
</code></pre>
<h2>Cipher Evaluation</h2>
<p>For many cryptograms there are a number of possible solutions. I ran into this when I first coded up the search and got
some gibberish results that clearly weren't right but technically were solutions because they were valid ciphers and the
decoded message was composed of dictionary words.</p>
<p>When I first ran the algorithm on the puzzle <code>PPF VIBQ KMF EKLC DIM!</code>, I got solutions like:</p>
<ul>
<li>"wood luck ind aims fun"</li>
<li>"wood luck ind hist fun"</li>
<li>"wood luck ind tier fun"</li>
<li>and so on...</li>
</ul>
<p>I could probably have guessed the actual solution from this, but I wanted the program to be able to rank the solutions
by how English-like they were.</p>
<p>My first approach used word frequency (which was included in the <a href="https://github.com/first20hours/google-10000-english">dictionary</a>
I was using). I thought scoring the solution by how common its words were would penalize solutions with the weird words I was seeing.
This didn't work great; the top results were:</p>
<ul>
<li>"good luck ind five run"</li>
<li>"good luck ind fits run"</li>
<li>"good luck ind five jun"</li>
<li>and so on...</li>
</ul>
<p>My next idea was score the solutions by the frequency of their word bigrams. This was done pretty easily using a corpus from
the Python <code>nltk</code> package, and put the correct solution much closer to the top:</p>
<ul>
<li>"good luck and have run"</li>
<li>"good luck and have sun"</li>
<li>"good luck and have fun"</li>
</ul>
<h2>More Puzzles</h2>
<p>A quote from Sonia Sotomayor:</p>
<div class="cryptogram"><p>X WK DBKZ KBF NRXBM HYKTN CF: X WKB'N CFHVTQF CJVFPA YJ KNRFQV' FEUFONHNXKBV KQ PFN KNRFQV WFAXBF CJ ZKQNR.</p></div>
<div class="solution"><p>I do know one thing about me: I don't measure myself by others' expectations or let others define my worth.</p></div>
<p>It turns out that the only guess the program needs to solve this one in a reasonable amount of time is what the single letter word is.
After that guess is provided it runs in around 10 seconds.</p>
<!-- blank lines in markdown remains a mystery... -->
<div style="margin-top: 3em;"></div>
<p>A quote from Gerald Ford:</p>
<div class="cryptogram"><p>G NQPBSDKBDX TUN BDQLNR XQ NUPB VQL BPBSVXRUDN VQL FGDX UJ G NQPBSDKBDX TUN BDQLNR XQ XGHB YSQK VQL BPBSVXRUDN VQL RGPB</p></div>
<div class="solution"><p>A government big enough to give you everything you want is a government big enough to take from you everything you have.</p></div>
<p>This one has a number of solutions, the first four of which are:</p>
<div class="solution">
  <ul>
    <li>A government big enough to give you everything you want is a government big enough to take from you everything you have.</li>
    <li>A government pig enough to give you everything you want is a government pig enough to take from you everything you have.</li>
    <li>A government dig enough to give you everything you want is a government dig enough to take from you everything you have.</li>
    <li>A government big enough to give you everything you cant is a government big enough to take from you everything you have.</li>
  </ul>
</div>
<p>This shows quite nicely how the bigram ranking of the solutions put them in a logical order.</p>
</div><h2>Code:</h2><div><pre style="-moz-tab-size:2;-o-tab-size:2;tab-size:2;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;white-space:pre-wrap;word-wrap:normal;font-family:Menlo, Monaco, &quot;Courier New&quot;, monospace;font-size:14px;color:#76d9e6;text-shadow:none;background:#2a2a2a;padding:15px;border-radius:4px;border:1px solid #e1e1e8;overflow:auto;position:relative"><code class="language-python" style="-moz-tab-size:2;-o-tab-size:2;tab-size:2;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;white-space:pre;word-wrap:normal;font-family:Menlo, Monaco, &quot;Courier New&quot;, monospace;font-size:14px;color:#76d9e6;text-shadow:none"><span class="token" style="color:#6f705e">#!/usr/bin/env python</span><span>
</span><span></span><span class="token" style="color:#6f705e"># coding: utf-8</span><span>
</span>
<span></span><span class="token" style="color:#6f705e"># In[1]:</span><span>
</span>
<!-- -->
<span></span><span class="token" style="color:#ef3b7d">import</span><span> copy
</span><span></span><span class="token" style="color:#ef3b7d">from</span><span> collections </span><span class="token" style="color:#ef3b7d">import</span><span> defaultdict
</span><span></span><span class="token" style="color:#ef3b7d">from</span><span> functools </span><span class="token" style="color:#ef3b7d">import</span><span> lru_cache</span><span class="token" style="color:#bebec5">,</span><span> </span><span class="token builtin">reduce</span><span>
</span><span></span><span class="token" style="color:#ef3b7d">from</span><span> pprint </span><span class="token" style="color:#ef3b7d">import</span><span> pprint
</span><span></span><span class="token" style="color:#ef3b7d">from</span><span> time </span><span class="token" style="color:#ef3b7d">import</span><span> time
</span>
<span></span><span class="token" style="color:#ef3b7d">import</span><span> nltk
</span>
<!-- -->
<span></span><span class="token" style="color:#6f705e"># In[2]:</span><span>
</span>
<!-- -->
<span></span><span class="token" style="color:#ef3b7d">with</span><span> </span><span class="token builtin">open</span><span class="token" style="color:#bebec5">(</span><span class="token" style="color:#e6d06c">&#x27;../google-10000-english/google-10000-english.txt&#x27;</span><span class="token" style="color:#bebec5">)</span><span> </span><span class="token" style="color:#ef3b7d">as</span><span> word_file</span><span class="token" style="color:#bebec5">:</span><span>
</span><span>    dictionary </span><span class="token" style="color:#a77afe">=</span><span> </span><span class="token builtin">set</span><span class="token" style="color:#bebec5">(</span><span>word_file</span><span class="token" style="color:#bebec5">.</span><span>read</span><span class="token" style="color:#bebec5">(</span><span class="token" style="color:#bebec5">)</span><span class="token" style="color:#bebec5">.</span><span>split</span><span class="token" style="color:#bebec5">(</span><span class="token" style="color:#bebec5">)</span><span class="token" style="color:#bebec5">)</span><span>
</span>
<!-- -->
<span></span><span class="token" style="color:#6f705e"># In[3]:</span><span>
</span>
<!-- -->
<span>MESSAGES </span><span class="token" style="color:#a77afe">=</span><span> </span><span class="token" style="color:#bebec5">[</span><span>x</span><span class="token" style="color:#bebec5">.</span><span>lower</span><span class="token" style="color:#bebec5">(</span><span class="token" style="color:#bebec5">)</span><span> </span><span class="token" style="color:#ef3b7d">for</span><span> x </span><span class="token" style="color:#ef3b7d">in</span><span>
</span><span>    </span><span class="token" style="color:#bebec5">[</span><span>
</span><span>        </span><span class="token" style="color:#e6d06c">&#x27;APPF VIBQ KMF EKLC DIM&#x27;</span><span class="token" style="color:#bebec5">,</span><span>
</span><span>        </span><span class="token" style="color:#e6d06c">&#x27;ZCA LIZIQA PV KMZ X EPLZ PZ PV XK XSCPAUAFAKZ AUAQR EAKAQXZPMK CAYTV FXHA PZV MJK LIZIQA ZCPV PV ZCA AVVAKZPXY SCXYYAKEA ML ZCA TQAVAKZ&#x27;</span><span class="token" style="color:#bebec5">,</span><span>
</span><span>        </span><span class="token" style="color:#e6d06c">&quot;X WK DBKZ KBF NRXBM HYKTN CF X WKBN CFHVTQF CJVFPA YJ KNRFQV FEUFONHNXKBV KQ PFN KNRFQV WFAXBF CJ ZKQNR&quot;</span><span class="token" style="color:#bebec5">,</span><span>
</span><span>        </span><span class="token" style="color:#e6d06c">&#x27;G NQPBSDKBDX TUN BDQLNR XQ NUPB VQL BPBSVXRUDN VQL FGDX UJ G NQPBSDKBDX TUN BDQLNR XQ XGHB YSQK VQL BPBSVXRUDN VQL RGPB&#x27;</span><span class="token" style="color:#bebec5">,</span><span>
</span><span>    </span><span class="token" style="color:#bebec5">]</span><span>
</span><span></span><span class="token" style="color:#bebec5">]</span><span>
</span>
<!-- -->
<span></span><span class="token" style="color:#6f705e"># In[4]:</span><span>
</span>
<!-- -->
<span></span><span class="token" style="color:#6f705e"># Ngrams are dictionaries of the triple (ngram, len, i) mapped to a set of</span><span>
</span><span></span><span class="token" style="color:#6f705e"># words of length `len` where the character ngram `ngram` appears at index `i`.</span><span>
</span><span></span><span class="token" style="color:#6f705e"># By including the word length and index in the key we can narrow down word matches later.</span><span>
</span><span>ngrams</span><span class="token" style="color:#bebec5">:</span><span> </span><span class="token" style="color:#e6d06c">&#x27;Dict[Tuple[str, int, int], Set[str]]&#x27;</span><span> </span><span class="token" style="color:#a77afe">=</span><span> defaultdict</span><span class="token" style="color:#bebec5">(</span><span class="token builtin">set</span><span class="token" style="color:#bebec5">)</span><span>
</span>
<span></span><span class="token" style="color:#6f705e"># words_by_length is a dictionary of word length to set of words</span><span>
</span><span>words_by_length</span><span class="token" style="color:#bebec5">:</span><span> </span><span class="token" style="color:#e6d06c">&#x27;Dict[int, Set[str]]&#x27;</span><span> </span><span class="token" style="color:#a77afe">=</span><span> defaultdict</span><span class="token" style="color:#bebec5">(</span><span class="token builtin">set</span><span class="token" style="color:#bebec5">)</span><span>
</span>    
<span>words_to_rank</span><span class="token" style="color:#bebec5">:</span><span> </span><span class="token" style="color:#e6d06c">&#x27;Dict[str, int]&#x27;</span><span> </span><span class="token" style="color:#a77afe">=</span><span> defaultdict</span><span class="token" style="color:#bebec5">(</span><span class="token" style="color:#ef3b7d">lambda</span><span class="token" style="color:#bebec5">:</span><span> 10_001</span><span class="token" style="color:#bebec5">)</span><span>
</span>
<span></span><span class="token" style="color:#ef3b7d">for</span><span> i</span><span class="token" style="color:#bebec5">,</span><span> word </span><span class="token" style="color:#ef3b7d">in</span><span> </span><span class="token builtin">enumerate</span><span class="token" style="color:#bebec5">(</span><span>dictionary</span><span class="token" style="color:#bebec5">)</span><span class="token" style="color:#bebec5">:</span><span>
</span><span>    words_by_length</span><span class="token" style="color:#bebec5">[</span><span class="token builtin">len</span><span class="token" style="color:#bebec5">(</span><span>word</span><span class="token" style="color:#bebec5">)</span><span class="token" style="color:#bebec5">]</span><span class="token" style="color:#bebec5">.</span><span>add</span><span class="token" style="color:#bebec5">(</span><span>word</span><span class="token" style="color:#bebec5">)</span><span>
</span><span>    words_to_rank</span><span class="token" style="color:#bebec5">[</span><span>word</span><span class="token" style="color:#bebec5">]</span><span> </span><span class="token" style="color:#a77afe">=</span><span> i
</span><span>    </span><span class="token" style="color:#ef3b7d">for</span><span> i </span><span class="token" style="color:#ef3b7d">in</span><span> </span><span class="token builtin">range</span><span class="token" style="color:#bebec5">(</span><span class="token" style="color:#a77afe">0</span><span class="token" style="color:#bebec5">,</span><span> </span><span class="token builtin">len</span><span class="token" style="color:#bebec5">(</span><span>word</span><span class="token" style="color:#bebec5">)</span><span class="token" style="color:#bebec5">)</span><span class="token" style="color:#bebec5">:</span><span>
</span><span>        ngrams</span><span class="token" style="color:#bebec5">[</span><span class="token" style="color:#bebec5">(</span><span>word</span><span class="token" style="color:#bebec5">[</span><span>i</span><span class="token" style="color:#bebec5">]</span><span class="token" style="color:#bebec5">,</span><span> </span><span class="token builtin">len</span><span class="token" style="color:#bebec5">(</span><span>word</span><span class="token" style="color:#bebec5">)</span><span class="token" style="color:#bebec5">,</span><span> i</span><span class="token" style="color:#bebec5">)</span><span class="token" style="color:#bebec5">]</span><span class="token" style="color:#bebec5">.</span><span>add</span><span class="token" style="color:#bebec5">(</span><span>word</span><span class="token" style="color:#bebec5">)</span><span>
</span><span>        </span><span class="token" style="color:#ef3b7d">if</span><span> i </span><span class="token" style="color:#a77afe">&lt;</span><span> </span><span class="token builtin">len</span><span class="token" style="color:#bebec5">(</span><span>word</span><span class="token" style="color:#bebec5">)</span><span> </span><span class="token" style="color:#a77afe">-</span><span> </span><span class="token" style="color:#a77afe">1</span><span class="token" style="color:#bebec5">:</span><span>
</span><span>            ngrams</span><span class="token" style="color:#bebec5">[</span><span class="token" style="color:#bebec5">(</span><span>word</span><span class="token" style="color:#bebec5">[</span><span>i</span><span class="token" style="color:#bebec5">:</span><span>i</span><span class="token" style="color:#a77afe">+</span><span class="token" style="color:#a77afe">2</span><span class="token" style="color:#bebec5">]</span><span class="token" style="color:#bebec5">,</span><span> </span><span class="token builtin">len</span><span class="token" style="color:#bebec5">(</span><span>word</span><span class="token" style="color:#bebec5">)</span><span class="token" style="color:#bebec5">,</span><span> i</span><span class="token" style="color:#bebec5">)</span><span class="token" style="color:#bebec5">]</span><span class="token" style="color:#bebec5">.</span><span>add</span><span class="token" style="color:#bebec5">(</span><span>word</span><span class="token" style="color:#bebec5">)</span><span>
</span><span>        </span><span class="token" style="color:#ef3b7d">if</span><span> i </span><span class="token" style="color:#a77afe">&lt;</span><span> </span><span class="token builtin">len</span><span class="token" style="color:#bebec5">(</span><span>word</span><span class="token" style="color:#bebec5">)</span><span> </span><span class="token" style="color:#a77afe">-</span><span> </span><span class="token" style="color:#a77afe">2</span><span class="token" style="color:#bebec5">:</span><span>
</span><span>            ngrams</span><span class="token" style="color:#bebec5">[</span><span class="token" style="color:#bebec5">(</span><span>word</span><span class="token" style="color:#bebec5">[</span><span>i</span><span class="token" style="color:#bebec5">:</span><span>i</span><span class="token" style="color:#a77afe">+</span><span class="token" style="color:#a77afe">3</span><span class="token" style="color:#bebec5">]</span><span class="token" style="color:#bebec5">,</span><span> </span><span class="token builtin">len</span><span class="token" style="color:#bebec5">(</span><span>word</span><span class="token" style="color:#bebec5">)</span><span class="token" style="color:#bebec5">,</span><span> i</span><span class="token" style="color:#bebec5">)</span><span class="token" style="color:#bebec5">]</span><span class="token" style="color:#bebec5">.</span><span>add</span><span class="token" style="color:#bebec5">(</span><span>word</span><span class="token" style="color:#bebec5">)</span><span>
</span>
<!-- -->
<span></span><span class="token" style="color:#6f705e"># In[5]:</span><span>
</span>
<!-- -->
<span>words </span><span class="token" style="color:#a77afe">=</span><span> </span><span class="token" style="color:#bebec5">[</span><span>w</span><span class="token" style="color:#bebec5">.</span><span>lower</span><span class="token" style="color:#bebec5">(</span><span class="token" style="color:#bebec5">)</span><span> </span><span class="token" style="color:#ef3b7d">for</span><span> w </span><span class="token" style="color:#ef3b7d">in</span><span> nltk</span><span class="token" style="color:#bebec5">.</span><span>corpus</span><span class="token" style="color:#bebec5">.</span><span>gutenberg</span><span class="token" style="color:#bebec5">.</span><span>words</span><span class="token" style="color:#bebec5">(</span><span class="token" style="color:#bebec5">)</span><span> </span><span class="token" style="color:#ef3b7d">if</span><span> w</span><span class="token" style="color:#bebec5">.</span><span>isalpha</span><span class="token" style="color:#bebec5">(</span><span class="token" style="color:#bebec5">)</span><span class="token" style="color:#bebec5">]</span><span>
</span><span>word_bigrams</span><span class="token" style="color:#bebec5">:</span><span> </span><span class="token" style="color:#e6d06c">&#x27;Dict[Tuple[str, str], int]&#x27;</span><span> </span><span class="token" style="color:#a77afe">=</span><span> defaultdict</span><span class="token" style="color:#bebec5">(</span><span class="token builtin">int</span><span class="token" style="color:#bebec5">)</span><span>
</span><span></span><span class="token" style="color:#ef3b7d">for</span><span> bigram </span><span class="token" style="color:#ef3b7d">in</span><span> nltk</span><span class="token" style="color:#bebec5">.</span><span>bigrams</span><span class="token" style="color:#bebec5">(</span><span>words</span><span class="token" style="color:#bebec5">)</span><span class="token" style="color:#bebec5">:</span><span>
</span><span>    word_bigrams</span><span class="token" style="color:#bebec5">[</span><span>bigram</span><span class="token" style="color:#bebec5">]</span><span> </span><span class="token" style="color:#a77afe">+=</span><span> </span><span class="token" style="color:#a77afe">1</span><span>
</span>
<!-- -->
<span></span><span class="token" style="color:#6f705e"># In[6]:</span><span>
</span>
<!-- -->
<span></span><span class="token" style="color:#6f705e"># what fraction of a candidate decoded message&#x27;s words are found in the dictionary?</span><span>
</span><span></span><span class="token" style="color:#6f705e">#</span><span>
</span><span></span><span class="token" style="color:#6f705e"># `message` should be lowercase</span><span>
</span><span></span><span class="token" style="color:#6f705e"># contractions appear in dictionary without apostrophes e.g. &quot;wont&quot;, &quot;shouldnt&quot;</span><span>
</span><span></span><span class="token" style="color:#ef3b7d">def</span><span> </span><span class="token function">compute_fraction_in_dictionary</span><span class="token" style="color:#bebec5">(</span><span>message</span><span class="token" style="color:#bebec5">:</span><span> </span><span class="token builtin">str</span><span class="token" style="color:#bebec5">)</span><span class="token" style="color:#bebec5">:</span><span>
</span><span>    message </span><span class="token" style="color:#a77afe">=</span><span> </span><span class="token" style="color:#e6d06c">&#x27;&#x27;</span><span class="token" style="color:#bebec5">.</span><span>join</span><span class="token" style="color:#bebec5">(</span><span class="token" style="color:#bebec5">[</span><span>c </span><span class="token" style="color:#ef3b7d">for</span><span> c </span><span class="token" style="color:#ef3b7d">in</span><span> message </span><span class="token" style="color:#ef3b7d">if</span><span> c</span><span class="token" style="color:#bebec5">.</span><span>isalpha</span><span class="token" style="color:#bebec5">(</span><span class="token" style="color:#bebec5">)</span><span> </span><span class="token" style="color:#ef3b7d">or</span><span> c </span><span class="token" style="color:#ef3b7d">in</span><span> </span><span class="token" style="color:#bebec5">(</span><span class="token" style="color:#e6d06c">&#x27; &#x27;</span><span class="token" style="color:#bebec5">,</span><span> </span><span class="token" style="color:#e6d06c">&#x27;-&#x27;</span><span class="token" style="color:#bebec5">)</span><span class="token" style="color:#bebec5">]</span><span class="token" style="color:#bebec5">)</span><span>
</span><span>    words </span><span class="token" style="color:#a77afe">=</span><span> message</span><span class="token" style="color:#bebec5">.</span><span>split</span><span class="token" style="color:#bebec5">(</span><span class="token" style="color:#bebec5">)</span><span>
</span><span>    in_dict </span><span class="token" style="color:#a77afe">=</span><span> </span><span class="token" style="color:#bebec5">[</span><span>w </span><span class="token" style="color:#ef3b7d">for</span><span> w </span><span class="token" style="color:#ef3b7d">in</span><span> words </span><span class="token" style="color:#ef3b7d">if</span><span> w </span><span class="token" style="color:#ef3b7d">in</span><span> dictionary</span><span class="token" style="color:#bebec5">]</span><span>
</span><span>    </span><span class="token" style="color:#ef3b7d">return</span><span> </span><span class="token builtin">len</span><span class="token" style="color:#bebec5">(</span><span>in_dict</span><span class="token" style="color:#bebec5">)</span><span> </span><span class="token" style="color:#a77afe">/</span><span> </span><span class="token builtin">len</span><span class="token" style="color:#bebec5">(</span><span>words</span><span class="token" style="color:#bebec5">)</span><span>
</span>
<!-- -->
<span></span><span class="token" style="color:#6f705e"># In[7]:</span><span>
</span>
<!-- -->
<span></span><span class="token" style="color:#6f705e"># given a cipher and an encrypted message, decode the message</span><span>
</span><span></span><span class="token" style="color:#6f705e"># a cipher is a mapping between &#x27;encrypted&#x27; and &#x27;decrypted&#x27; characters</span><span>
</span><span></span><span class="token" style="color:#ef3b7d">def</span><span> </span><span class="token function">decode</span><span class="token" style="color:#bebec5">(</span><span>message</span><span class="token" style="color:#bebec5">:</span><span> </span><span class="token builtin">str</span><span class="token" style="color:#bebec5">,</span><span> cipher</span><span class="token" style="color:#bebec5">:</span><span> </span><span class="token" style="color:#e6d06c">&#x27;Dict[str, str]&#x27;</span><span class="token" style="color:#bebec5">)</span><span> </span><span class="token" style="color:#a77afe">-</span><span class="token" style="color:#a77afe">&gt;</span><span> </span><span class="token builtin">str</span><span class="token" style="color:#bebec5">:</span><span>
</span><span>    result </span><span class="token" style="color:#a77afe">=</span><span> </span><span class="token" style="color:#e6d06c">&#x27;&#x27;</span><span>
</span><span>    </span><span class="token" style="color:#ef3b7d">for</span><span> char </span><span class="token" style="color:#ef3b7d">in</span><span> message</span><span class="token" style="color:#bebec5">:</span><span>
</span><span>        </span><span class="token" style="color:#ef3b7d">if</span><span> </span><span class="token" style="color:#ef3b7d">not</span><span> char</span><span class="token" style="color:#bebec5">.</span><span>isalpha</span><span class="token" style="color:#bebec5">(</span><span class="token" style="color:#bebec5">)</span><span class="token" style="color:#bebec5">:</span><span>
</span><span>            result </span><span class="token" style="color:#a77afe">+=</span><span> char
</span><span>        </span><span class="token" style="color:#ef3b7d">elif</span><span> char </span><span class="token" style="color:#ef3b7d">in</span><span> cipher</span><span class="token" style="color:#bebec5">:</span><span>
</span><span>            result </span><span class="token" style="color:#a77afe">+=</span><span> cipher</span><span class="token" style="color:#bebec5">[</span><span>char</span><span class="token" style="color:#bebec5">]</span><span>
</span><span>        </span><span class="token" style="color:#ef3b7d">else</span><span class="token" style="color:#bebec5">:</span><span>
</span><span>            result </span><span class="token" style="color:#a77afe">+=</span><span> </span><span class="token" style="color:#e6d06c">&#x27;-&#x27;</span><span>
</span><span>    </span><span class="token" style="color:#ef3b7d">return</span><span> result
</span>
<!-- -->
<span></span><span class="token" style="color:#6f705e"># In[8]:</span><span>
</span>
<!-- -->
<span></span><span class="token" style="color:#6f705e"># a cipher is valid if values don&#x27;t repeat</span><span>
</span><span></span><span class="token" style="color:#ef3b7d">def</span><span> </span><span class="token function">validate_cipher</span><span class="token" style="color:#bebec5">(</span><span>cipher</span><span class="token" style="color:#bebec5">:</span><span> </span><span class="token" style="color:#e6d06c">&#x27;Dict[str, str]&#x27;</span><span class="token" style="color:#bebec5">)</span><span> </span><span class="token" style="color:#a77afe">-</span><span class="token" style="color:#a77afe">&gt;</span><span> </span><span class="token builtin">bool</span><span class="token" style="color:#bebec5">:</span><span>
</span><span>    </span><span class="token" style="color:#ef3b7d">return</span><span> </span><span class="token builtin">len</span><span class="token" style="color:#bebec5">(</span><span>cipher</span><span class="token" style="color:#bebec5">.</span><span>values</span><span class="token" style="color:#bebec5">(</span><span class="token" style="color:#bebec5">)</span><span class="token" style="color:#bebec5">)</span><span> </span><span class="token" style="color:#a77afe">==</span><span> </span><span class="token builtin">len</span><span class="token" style="color:#bebec5">(</span><span class="token builtin">set</span><span class="token" style="color:#bebec5">(</span><span>cipher</span><span class="token" style="color:#bebec5">.</span><span>values</span><span class="token" style="color:#bebec5">(</span><span class="token" style="color:#bebec5">)</span><span class="token" style="color:#bebec5">)</span><span class="token" style="color:#bebec5">)</span><span>
</span>
<!-- -->
<span></span><span class="token" style="color:#6f705e"># In[9]:</span><span>
</span>
<!-- -->
<span></span><span class="token" style="color:#6f705e"># Higher score is better. Doesn&#x27;t normalize for message length.</span><span>
</span><span></span><span class="token" style="color:#ef3b7d">def</span><span> </span><span class="token function">score_cipher</span><span class="token" style="color:#bebec5">(</span><span>message</span><span class="token" style="color:#bebec5">:</span><span> </span><span class="token builtin">str</span><span class="token" style="color:#bebec5">,</span><span> cipher</span><span class="token" style="color:#bebec5">:</span><span> </span><span class="token" style="color:#e6d06c">&#x27;Dict[str, str]&#x27;</span><span class="token" style="color:#bebec5">)</span><span> </span><span class="token" style="color:#a77afe">-</span><span class="token" style="color:#a77afe">&gt;</span><span> </span><span class="token builtin">float</span><span class="token" style="color:#bebec5">:</span><span>
</span><span>    decoded_words </span><span class="token" style="color:#a77afe">=</span><span> decode</span><span class="token" style="color:#bebec5">(</span><span>message</span><span class="token" style="color:#bebec5">,</span><span> cipher</span><span class="token" style="color:#bebec5">)</span><span class="token" style="color:#bebec5">.</span><span>split</span><span class="token" style="color:#bebec5">(</span><span class="token" style="color:#bebec5">)</span><span>
</span>
<span>    </span><span class="token" style="color:#6f705e"># by word popularity</span><span>
</span><span></span><span class="token" style="color:#6f705e">#     return -1 * sum([words_to_rank[w] for w in decoded_words])</span><span>
</span>
<span>    </span><span class="token" style="color:#6f705e"># by bigram popularity</span><span>
</span><span>    bigrams </span><span class="token" style="color:#a77afe">=</span><span> nltk</span><span class="token" style="color:#bebec5">.</span><span>bigrams</span><span class="token" style="color:#bebec5">(</span><span>decoded_words</span><span class="token" style="color:#bebec5">)</span><span>
</span><span>    </span><span class="token" style="color:#ef3b7d">return</span><span> </span><span class="token builtin">sum</span><span class="token" style="color:#bebec5">(</span><span class="token" style="color:#bebec5">[</span><span>word_bigrams</span><span class="token" style="color:#bebec5">[</span><span>b</span><span class="token" style="color:#bebec5">]</span><span> </span><span class="token" style="color:#ef3b7d">for</span><span> b </span><span class="token" style="color:#ef3b7d">in</span><span> bigrams</span><span class="token" style="color:#bebec5">]</span><span class="token" style="color:#bebec5">)</span><span>
</span>
<!-- -->
<span></span><span class="token" style="color:#6f705e"># In[10]:</span><span>
</span>
<!-- -->
<span></span><span class="token decorator annotation" style="color:#bebec5">@lru_cache</span><span class="token" style="color:#bebec5">(</span><span>maxsize</span><span class="token" style="color:#a77afe">=</span><span class="token" style="color:#a77afe">None</span><span class="token" style="color:#bebec5">)</span><span>
</span><span></span><span class="token" style="color:#ef3b7d">def</span><span> </span><span class="token function">find_words_matching_pattern</span><span class="token" style="color:#bebec5">(</span><span>template</span><span class="token" style="color:#bebec5">:</span><span> </span><span class="token builtin">str</span><span class="token" style="color:#bebec5">)</span><span> </span><span class="token" style="color:#a77afe">-</span><span class="token" style="color:#a77afe">&gt;</span><span> </span><span class="token" style="color:#e6d06c">&#x27;Set[str]&#x27;</span><span class="token" style="color:#bebec5">:</span><span>
</span><span>    </span><span class="token" style="color:#6f705e"># Given a pattern, return words from dictionary that match. &quot;-&quot; is a wildcard.</span><span>
</span><span>    </span><span class="token" style="color:#6f705e"># E.g. &quot;-ood&quot; -&gt; {&quot;good&quot;, &quot;hood&quot;, ...}</span><span>
</span><span>    </span><span class="token" style="color:#ef3b7d">if</span><span> template</span><span class="token" style="color:#bebec5">.</span><span>isalpha</span><span class="token" style="color:#bebec5">(</span><span class="token" style="color:#bebec5">)</span><span class="token" style="color:#bebec5">:</span><span>
</span><span>        </span><span class="token" style="color:#ef3b7d">return</span><span> </span><span class="token builtin">set</span><span class="token" style="color:#bebec5">(</span><span class="token" style="color:#bebec5">[</span><span>template</span><span class="token" style="color:#bebec5">]</span><span class="token" style="color:#bebec5">)</span><span>
</span>
<span>    ngram_word_matches</span><span class="token" style="color:#bebec5">:</span><span> </span><span class="token" style="color:#e6d06c">&#x27;List[set]&#x27;</span><span> </span><span class="token" style="color:#a77afe">=</span><span> </span><span class="token" style="color:#bebec5">[</span><span class="token" style="color:#bebec5">]</span><span>
</span><span>    </span><span class="token" style="color:#6f705e"># look for decoded ngrams</span><span>
</span><span>    </span><span class="token" style="color:#ef3b7d">for</span><span> i </span><span class="token" style="color:#ef3b7d">in</span><span> </span><span class="token builtin">range</span><span class="token" style="color:#bebec5">(</span><span class="token" style="color:#a77afe">0</span><span class="token" style="color:#bebec5">,</span><span> </span><span class="token builtin">len</span><span class="token" style="color:#bebec5">(</span><span>template</span><span class="token" style="color:#bebec5">)</span><span class="token" style="color:#bebec5">)</span><span class="token" style="color:#bebec5">:</span><span>
</span><span>        </span><span class="token" style="color:#ef3b7d">if</span><span> template</span><span class="token" style="color:#bebec5">[</span><span>i</span><span class="token" style="color:#bebec5">]</span><span class="token" style="color:#bebec5">.</span><span>isalpha</span><span class="token" style="color:#bebec5">(</span><span class="token" style="color:#bebec5">)</span><span class="token" style="color:#bebec5">:</span><span>
</span><span>            ngram_word_matches</span><span class="token" style="color:#bebec5">.</span><span>append</span><span class="token" style="color:#bebec5">(</span><span>ngrams</span><span class="token" style="color:#bebec5">[</span><span class="token" style="color:#bebec5">(</span><span>template</span><span class="token" style="color:#bebec5">[</span><span>i</span><span class="token" style="color:#bebec5">]</span><span class="token" style="color:#bebec5">,</span><span> </span><span class="token builtin">len</span><span class="token" style="color:#bebec5">(</span><span>template</span><span class="token" style="color:#bebec5">)</span><span class="token" style="color:#bebec5">,</span><span> i</span><span class="token" style="color:#bebec5">)</span><span class="token" style="color:#bebec5">]</span><span class="token" style="color:#bebec5">)</span><span>
</span><span>        </span><span class="token" style="color:#ef3b7d">if</span><span> i </span><span class="token" style="color:#a77afe">&lt;</span><span> </span><span class="token builtin">len</span><span class="token" style="color:#bebec5">(</span><span>template</span><span class="token" style="color:#bebec5">)</span><span> </span><span class="token" style="color:#a77afe">-</span><span> </span><span class="token" style="color:#a77afe">1</span><span> </span><span class="token" style="color:#ef3b7d">and</span><span> template</span><span class="token" style="color:#bebec5">[</span><span>i</span><span class="token" style="color:#bebec5">:</span><span>i</span><span class="token" style="color:#a77afe">+</span><span class="token" style="color:#a77afe">2</span><span class="token" style="color:#bebec5">]</span><span class="token" style="color:#bebec5">.</span><span>isalpha</span><span class="token" style="color:#bebec5">(</span><span class="token" style="color:#bebec5">)</span><span class="token" style="color:#bebec5">:</span><span>
</span><span>            ngram_word_matches</span><span class="token" style="color:#bebec5">.</span><span>append</span><span class="token" style="color:#bebec5">(</span><span>ngrams</span><span class="token" style="color:#bebec5">[</span><span class="token" style="color:#bebec5">(</span><span>template</span><span class="token" style="color:#bebec5">[</span><span>i</span><span class="token" style="color:#bebec5">:</span><span>i</span><span class="token" style="color:#a77afe">+</span><span class="token" style="color:#a77afe">2</span><span class="token" style="color:#bebec5">]</span><span class="token" style="color:#bebec5">,</span><span> </span><span class="token builtin">len</span><span class="token" style="color:#bebec5">(</span><span>template</span><span class="token" style="color:#bebec5">)</span><span class="token" style="color:#bebec5">,</span><span> i</span><span class="token" style="color:#bebec5">)</span><span class="token" style="color:#bebec5">]</span><span class="token" style="color:#bebec5">)</span><span>
</span><span>        </span><span class="token" style="color:#ef3b7d">if</span><span> i </span><span class="token" style="color:#a77afe">&lt;</span><span> </span><span class="token builtin">len</span><span class="token" style="color:#bebec5">(</span><span>template</span><span class="token" style="color:#bebec5">)</span><span> </span><span class="token" style="color:#a77afe">-</span><span> </span><span class="token" style="color:#a77afe">2</span><span> </span><span class="token" style="color:#ef3b7d">and</span><span> template</span><span class="token" style="color:#bebec5">[</span><span>i</span><span class="token" style="color:#bebec5">:</span><span>i</span><span class="token" style="color:#a77afe">+</span><span class="token" style="color:#a77afe">3</span><span class="token" style="color:#bebec5">]</span><span class="token" style="color:#bebec5">.</span><span>isalpha</span><span class="token" style="color:#bebec5">(</span><span class="token" style="color:#bebec5">)</span><span class="token" style="color:#bebec5">:</span><span>
</span><span>            ngram_word_matches</span><span class="token" style="color:#bebec5">.</span><span>append</span><span class="token" style="color:#bebec5">(</span><span>ngrams</span><span class="token" style="color:#bebec5">[</span><span class="token" style="color:#bebec5">(</span><span>template</span><span class="token" style="color:#bebec5">[</span><span>i</span><span class="token" style="color:#bebec5">:</span><span>i</span><span class="token" style="color:#a77afe">+</span><span class="token" style="color:#a77afe">3</span><span class="token" style="color:#bebec5">]</span><span class="token" style="color:#bebec5">,</span><span> </span><span class="token builtin">len</span><span class="token" style="color:#bebec5">(</span><span>template</span><span class="token" style="color:#bebec5">)</span><span class="token" style="color:#bebec5">,</span><span> i</span><span class="token" style="color:#bebec5">)</span><span class="token" style="color:#bebec5">]</span><span class="token" style="color:#bebec5">)</span><span>
</span>
<span>    ngram_word_matches </span><span class="token" style="color:#a77afe">=</span><span> </span><span class="token" style="color:#bebec5">[</span><span>s </span><span class="token" style="color:#ef3b7d">for</span><span> s </span><span class="token" style="color:#ef3b7d">in</span><span> ngram_word_matches </span><span class="token" style="color:#ef3b7d">if</span><span> </span><span class="token builtin">len</span><span class="token" style="color:#bebec5">(</span><span>s</span><span class="token" style="color:#bebec5">)</span><span> </span><span class="token" style="color:#a77afe">&gt;</span><span> </span><span class="token" style="color:#a77afe">0</span><span class="token" style="color:#bebec5">]</span><span>
</span><span>    </span><span class="token" style="color:#ef3b7d">if</span><span> ngram_word_matches</span><span class="token" style="color:#bebec5">:</span><span>
</span><span>        </span><span class="token" style="color:#ef3b7d">return</span><span> </span><span class="token builtin">reduce</span><span class="token" style="color:#bebec5">(</span><span class="token" style="color:#ef3b7d">lambda</span><span> a</span><span class="token" style="color:#bebec5">,</span><span> b</span><span class="token" style="color:#bebec5">:</span><span> a </span><span class="token" style="color:#a77afe">&amp;</span><span> b</span><span class="token" style="color:#bebec5">,</span><span> ngram_word_matches</span><span class="token" style="color:#bebec5">)</span><span>
</span><span>    </span><span class="token" style="color:#ef3b7d">else</span><span class="token" style="color:#bebec5">:</span><span>
</span><span>        </span><span class="token" style="color:#ef3b7d">return</span><span> words_by_length</span><span class="token" style="color:#bebec5">[</span><span class="token builtin">len</span><span class="token" style="color:#bebec5">(</span><span>template</span><span class="token" style="color:#bebec5">)</span><span class="token" style="color:#bebec5">]</span><span>
</span>
<!-- -->
<span></span><span class="token" style="color:#6f705e"># In[11]:</span><span>
</span>
<!-- -->
<span></span><span class="token" style="color:#ef3b7d">def</span><span> </span><span class="token function">optimize_cipher</span><span class="token" style="color:#bebec5">(</span><span>
</span><span>    message</span><span class="token" style="color:#bebec5">:</span><span> </span><span class="token builtin">str</span><span class="token" style="color:#bebec5">,</span><span>
</span><span>    cipher</span><span class="token" style="color:#bebec5">:</span><span> </span><span class="token" style="color:#e6d06c">&#x27;Dict[str, str]&#x27;</span><span class="token" style="color:#bebec5">,</span><span>
</span><span></span><span class="token" style="color:#bebec5">)</span><span> </span><span class="token" style="color:#a77afe">-</span><span class="token" style="color:#a77afe">&gt;</span><span> </span><span class="token" style="color:#e6d06c">&#x27;List[Tuple[Dict[str, str], float]]&#x27;</span><span class="token" style="color:#bebec5">:</span><span>
</span><span>    </span><span class="token" style="color:#6f705e"># Given a message and an incomplete cipher, return a list of</span><span>
</span><span>    </span><span class="token" style="color:#6f705e"># completed ciphers and their scores.</span><span>
</span><span>    </span><span class="token" style="color:#6f705e"># Currently doesn&#x27;t handle any punctuation (periods, apostrophes, etc.)</span><span>
</span><span>    </span><span class="token" style="color:#ef3b7d">if</span><span> </span><span class="token" style="color:#ef3b7d">not</span><span> </span><span class="token builtin">all</span><span class="token" style="color:#bebec5">(</span><span class="token" style="color:#bebec5">[</span><span>c</span><span class="token" style="color:#bebec5">.</span><span>isalpha</span><span class="token" style="color:#bebec5">(</span><span class="token" style="color:#bebec5">)</span><span> </span><span class="token" style="color:#ef3b7d">or</span><span> c </span><span class="token" style="color:#a77afe">==</span><span> </span><span class="token" style="color:#e6d06c">&#x27; &#x27;</span><span> </span><span class="token" style="color:#ef3b7d">for</span><span> c </span><span class="token" style="color:#ef3b7d">in</span><span> message</span><span class="token" style="color:#bebec5">]</span><span class="token" style="color:#bebec5">)</span><span class="token" style="color:#bebec5">:</span><span>
</span><span>        </span><span class="token" style="color:#ef3b7d">raise</span><span> ValueError</span><span class="token" style="color:#bebec5">(</span><span class="token" style="color:#e6d06c">&quot;Message should only contain letters.&quot;</span><span class="token" style="color:#bebec5">)</span><span>
</span><span>    message </span><span class="token" style="color:#a77afe">=</span><span> message</span><span class="token" style="color:#bebec5">.</span><span>lower</span><span class="token" style="color:#bebec5">(</span><span class="token" style="color:#bebec5">)</span><span>
</span>
<span>    possible_new_ciphers </span><span class="token" style="color:#a77afe">=</span><span> generate_possible_new_ciphers</span><span class="token" style="color:#bebec5">(</span><span>
</span><span>        message</span><span class="token" style="color:#bebec5">.</span><span>split</span><span class="token" style="color:#bebec5">(</span><span class="token" style="color:#bebec5">)</span><span class="token" style="color:#bebec5">,</span><span>
</span><span>        cipher</span><span class="token" style="color:#bebec5">,</span><span>
</span><span>    </span><span class="token" style="color:#bebec5">)</span><span>
</span><span>    scored_ciphers </span><span class="token" style="color:#a77afe">=</span><span> </span><span class="token" style="color:#bebec5">[</span><span class="token" style="color:#bebec5">(</span><span>cipher</span><span class="token" style="color:#bebec5">,</span><span> score_cipher</span><span class="token" style="color:#bebec5">(</span><span>message</span><span class="token" style="color:#bebec5">,</span><span> cipher</span><span class="token" style="color:#bebec5">)</span><span class="token" style="color:#bebec5">)</span><span> </span><span class="token" style="color:#ef3b7d">for</span><span> cipher </span><span class="token" style="color:#ef3b7d">in</span><span> possible_new_ciphers</span><span class="token" style="color:#bebec5">]</span><span>
</span><span>    </span><span class="token" style="color:#ef3b7d">return</span><span> </span><span class="token builtin">sorted</span><span class="token" style="color:#bebec5">(</span><span>scored_ciphers</span><span class="token" style="color:#bebec5">,</span><span> key</span><span class="token" style="color:#a77afe">=</span><span class="token" style="color:#ef3b7d">lambda</span><span> t</span><span class="token" style="color:#bebec5">:</span><span> t</span><span class="token" style="color:#bebec5">[</span><span class="token" style="color:#a77afe">1</span><span class="token" style="color:#bebec5">]</span><span class="token" style="color:#bebec5">,</span><span> reverse</span><span class="token" style="color:#a77afe">=</span><span class="token" style="color:#a77afe">True</span><span class="token" style="color:#bebec5">)</span><span>
</span>
<span></span><span class="token" style="color:#ef3b7d">def</span><span> </span><span class="token function">generate_possible_new_ciphers</span><span class="token" style="color:#bebec5">(</span><span>
</span><span>    message_words</span><span class="token" style="color:#bebec5">:</span><span> </span><span class="token" style="color:#e6d06c">&#x27;List[str]&#x27;</span><span class="token" style="color:#bebec5">,</span><span>
</span><span>    working_cipher</span><span class="token" style="color:#bebec5">:</span><span> </span><span class="token" style="color:#e6d06c">&#x27;Dict[str, str]&#x27;</span><span class="token" style="color:#bebec5">,</span><span>
</span><span></span><span class="token" style="color:#bebec5">)</span><span> </span><span class="token" style="color:#a77afe">-</span><span class="token" style="color:#a77afe">&gt;</span><span> </span><span class="token" style="color:#e6d06c">&#x27;List[Dict[str, str]]&#x27;</span><span class="token" style="color:#bebec5">:</span><span>
</span><span>    </span><span class="token" style="color:#6f705e"># For every word we found a bigram in we now have a set of possible decoded words.</span><span>
</span><span>    </span><span class="token" style="color:#6f705e"># Each decoded word implies an expanded cipher using the letters that were previously</span><span>
</span><span>    </span><span class="token" style="color:#6f705e"># encoded, so we return combinations of non-conflicting ciphers.</span><span>
</span><span>    </span><span class="token" style="color:#ef3b7d">assert</span><span class="token" style="color:#bebec5">(</span><span>validate_cipher</span><span class="token" style="color:#bebec5">(</span><span>working_cipher</span><span class="token" style="color:#bebec5">)</span><span class="token" style="color:#bebec5">)</span><span>
</span>
<span>    result </span><span class="token" style="color:#a77afe">=</span><span> </span><span class="token" style="color:#bebec5">[</span><span class="token" style="color:#bebec5">]</span><span>
</span><span>    possible_word_matches </span><span class="token" style="color:#a77afe">=</span><span> find_words_matching_pattern</span><span class="token" style="color:#bebec5">(</span><span>decode</span><span class="token" style="color:#bebec5">(</span><span>message_words</span><span class="token" style="color:#bebec5">[</span><span class="token" style="color:#a77afe">0</span><span class="token" style="color:#bebec5">]</span><span class="token" style="color:#bebec5">,</span><span> working_cipher</span><span class="token" style="color:#bebec5">)</span><span class="token" style="color:#bebec5">)</span><span>
</span><span>    </span><span class="token" style="color:#ef3b7d">for</span><span> word </span><span class="token" style="color:#ef3b7d">in</span><span> possible_word_matches</span><span class="token" style="color:#bebec5">:</span><span>
</span><span>        new_cipher </span><span class="token" style="color:#a77afe">=</span><span> generate_new_cipher</span><span class="token" style="color:#bebec5">(</span><span>message_words</span><span class="token" style="color:#bebec5">[</span><span class="token" style="color:#a77afe">0</span><span class="token" style="color:#bebec5">]</span><span class="token" style="color:#bebec5">,</span><span> word</span><span class="token" style="color:#bebec5">)</span><span>
</span><span>        </span><span class="token" style="color:#6f705e"># a valid cipher will not always be generated: e.g. generate_new_cipher(&quot;abcd&quot;, &quot;lulu&quot;)</span><span>
</span><span>        </span><span class="token" style="color:#ef3b7d">if</span><span> validate_cipher</span><span class="token" style="color:#bebec5">(</span><span>new_cipher</span><span class="token" style="color:#bebec5">)</span><span> </span><span class="token" style="color:#ef3b7d">and</span><span> </span><span class="token" style="color:#ef3b7d">not</span><span> ciphers_conflict</span><span class="token" style="color:#bebec5">(</span><span>working_cipher</span><span class="token" style="color:#bebec5">,</span><span> new_cipher</span><span class="token" style="color:#bebec5">)</span><span class="token" style="color:#bebec5">:</span><span>
</span><span>            new_cipher</span><span class="token" style="color:#bebec5">.</span><span>update</span><span class="token" style="color:#bebec5">(</span><span>working_cipher</span><span class="token" style="color:#bebec5">)</span><span>
</span><span>            </span><span class="token" style="color:#ef3b7d">if</span><span> </span><span class="token builtin">len</span><span class="token" style="color:#bebec5">(</span><span>message_words</span><span class="token" style="color:#bebec5">)</span><span> </span><span class="token" style="color:#a77afe">==</span><span> </span><span class="token" style="color:#a77afe">1</span><span class="token" style="color:#bebec5">:</span><span>
</span><span>                result </span><span class="token" style="color:#a77afe">+=</span><span> </span><span class="token" style="color:#bebec5">[</span><span>new_cipher</span><span class="token" style="color:#bebec5">]</span><span>
</span><span>            </span><span class="token" style="color:#ef3b7d">else</span><span class="token" style="color:#bebec5">:</span><span>
</span><span>                result </span><span class="token" style="color:#a77afe">+=</span><span> generate_possible_new_ciphers</span><span class="token" style="color:#bebec5">(</span><span>
</span><span>                      message_words</span><span class="token" style="color:#bebec5">[</span><span class="token" style="color:#a77afe">1</span><span class="token" style="color:#bebec5">:</span><span class="token" style="color:#bebec5">]</span><span class="token" style="color:#bebec5">,</span><span>
</span><span>                      copy</span><span class="token" style="color:#bebec5">.</span><span>copy</span><span class="token" style="color:#bebec5">(</span><span>new_cipher</span><span class="token" style="color:#bebec5">)</span><span class="token" style="color:#bebec5">,</span><span>
</span><span>                  </span><span class="token" style="color:#bebec5">)</span><span>
</span><span>    </span><span class="token" style="color:#ef3b7d">return</span><span> result
</span>
<!-- -->
<span></span><span class="token" style="color:#ef3b7d">def</span><span> </span><span class="token function">generate_new_cipher</span><span class="token" style="color:#bebec5">(</span><span>original_word</span><span class="token" style="color:#bebec5">,</span><span> decoded_word</span><span class="token" style="color:#bebec5">)</span><span> </span><span class="token" style="color:#a77afe">-</span><span class="token" style="color:#a77afe">&gt;</span><span> </span><span class="token" style="color:#e6d06c">&#x27;Dict[str, str]&#x27;</span><span class="token" style="color:#bebec5">:</span><span>
</span><span>    </span><span class="token" style="color:#6f705e"># should actually probably only generate parts of the cipher that are new</span><span>
</span><span>    </span><span class="token" style="color:#ef3b7d">assert</span><span> </span><span class="token builtin">len</span><span class="token" style="color:#bebec5">(</span><span>original_word</span><span class="token" style="color:#bebec5">)</span><span> </span><span class="token" style="color:#a77afe">==</span><span> </span><span class="token builtin">len</span><span class="token" style="color:#bebec5">(</span><span>decoded_word</span><span class="token" style="color:#bebec5">)</span><span>
</span><span>    cipher </span><span class="token" style="color:#a77afe">=</span><span> </span><span class="token" style="color:#bebec5">{</span><span class="token" style="color:#bebec5">}</span><span>
</span><span>    </span><span class="token" style="color:#ef3b7d">for</span><span> i </span><span class="token" style="color:#ef3b7d">in</span><span> </span><span class="token builtin">range</span><span class="token" style="color:#bebec5">(</span><span class="token" style="color:#a77afe">0</span><span class="token" style="color:#bebec5">,</span><span> </span><span class="token builtin">len</span><span class="token" style="color:#bebec5">(</span><span>original_word</span><span class="token" style="color:#bebec5">)</span><span class="token" style="color:#bebec5">)</span><span class="token" style="color:#bebec5">:</span><span>
</span><span>        </span><span class="token" style="color:#ef3b7d">if</span><span> decoded_word</span><span class="token" style="color:#bebec5">[</span><span>i</span><span class="token" style="color:#bebec5">]</span><span> </span><span class="token" style="color:#a77afe">!=</span><span> </span><span class="token" style="color:#e6d06c">&#x27;-&#x27;</span><span class="token" style="color:#bebec5">:</span><span>
</span><span>            cipher</span><span class="token" style="color:#bebec5">[</span><span>original_word</span><span class="token" style="color:#bebec5">[</span><span>i</span><span class="token" style="color:#bebec5">]</span><span class="token" style="color:#bebec5">]</span><span> </span><span class="token" style="color:#a77afe">=</span><span> decoded_word</span><span class="token" style="color:#bebec5">[</span><span>i</span><span class="token" style="color:#bebec5">]</span><span>
</span><span>    </span><span class="token" style="color:#ef3b7d">return</span><span> cipher
</span>
<span></span><span class="token" style="color:#ef3b7d">def</span><span> </span><span class="token function">invert_cipher</span><span class="token" style="color:#bebec5">(</span><span>cipher</span><span class="token" style="color:#bebec5">:</span><span> </span><span class="token" style="color:#e6d06c">&#x27;Dict[str, str]&#x27;</span><span class="token" style="color:#bebec5">)</span><span> </span><span class="token" style="color:#a77afe">-</span><span class="token" style="color:#a77afe">&gt;</span><span> </span><span class="token" style="color:#e6d06c">&#x27;Dict[str, str]&#x27;</span><span class="token" style="color:#bebec5">:</span><span>
</span><span>    </span><span class="token" style="color:#ef3b7d">return</span><span> </span><span class="token" style="color:#bebec5">{</span><span>v</span><span class="token" style="color:#bebec5">:</span><span> k </span><span class="token" style="color:#ef3b7d">for</span><span> k</span><span class="token" style="color:#bebec5">,</span><span> v </span><span class="token" style="color:#ef3b7d">in</span><span> cipher</span><span class="token" style="color:#bebec5">.</span><span>items</span><span class="token" style="color:#bebec5">(</span><span class="token" style="color:#bebec5">)</span><span class="token" style="color:#bebec5">}</span><span>
</span>
<span></span><span class="token" style="color:#ef3b7d">def</span><span> </span><span class="token function">ciphers_conflict</span><span class="token" style="color:#bebec5">(</span><span>cipher1</span><span class="token" style="color:#bebec5">:</span><span> </span><span class="token" style="color:#e6d06c">&#x27;Dict[str, str]&#x27;</span><span class="token" style="color:#bebec5">,</span><span> cipher2</span><span class="token" style="color:#bebec5">:</span><span> </span><span class="token" style="color:#e6d06c">&#x27;Dict[str, str]&#x27;</span><span class="token" style="color:#bebec5">)</span><span> </span><span class="token" style="color:#a77afe">-</span><span class="token" style="color:#a77afe">&gt;</span><span> </span><span class="token builtin">bool</span><span class="token" style="color:#bebec5">:</span><span>
</span><span>    </span><span class="token" style="color:#ef3b7d">assert</span><span class="token" style="color:#bebec5">(</span><span>validate_cipher</span><span class="token" style="color:#bebec5">(</span><span>cipher1</span><span class="token" style="color:#bebec5">)</span><span> </span><span class="token" style="color:#ef3b7d">and</span><span> validate_cipher</span><span class="token" style="color:#bebec5">(</span><span>cipher2</span><span class="token" style="color:#bebec5">)</span><span class="token" style="color:#bebec5">)</span><span>
</span><span>    cipher1_inverse </span><span class="token" style="color:#a77afe">=</span><span> invert_cipher</span><span class="token" style="color:#bebec5">(</span><span>cipher1</span><span class="token" style="color:#bebec5">)</span><span>
</span><span>    </span><span class="token" style="color:#ef3b7d">for</span><span> k</span><span class="token" style="color:#bebec5">,</span><span> v </span><span class="token" style="color:#ef3b7d">in</span><span> cipher2</span><span class="token" style="color:#bebec5">.</span><span>items</span><span class="token" style="color:#bebec5">(</span><span class="token" style="color:#bebec5">)</span><span class="token" style="color:#bebec5">:</span><span>
</span><span>        </span><span class="token" style="color:#ef3b7d">if</span><span> </span><span class="token" style="color:#bebec5">(</span><span>k </span><span class="token" style="color:#ef3b7d">in</span><span> cipher1 </span><span class="token" style="color:#ef3b7d">and</span><span> v </span><span class="token" style="color:#a77afe">!=</span><span> cipher1</span><span class="token" style="color:#bebec5">[</span><span>k</span><span class="token" style="color:#bebec5">]</span><span> </span><span class="token" style="color:#ef3b7d">or</span><span>
</span><span>            v </span><span class="token" style="color:#ef3b7d">in</span><span> cipher1_inverse </span><span class="token" style="color:#ef3b7d">and</span><span> k </span><span class="token" style="color:#a77afe">!=</span><span> cipher1_inverse</span><span class="token" style="color:#bebec5">[</span><span>v</span><span class="token" style="color:#bebec5">]</span><span class="token" style="color:#bebec5">)</span><span class="token" style="color:#bebec5">:</span><span>
</span><span>            </span><span class="token" style="color:#ef3b7d">return</span><span> </span><span class="token" style="color:#a77afe">True</span><span>
</span><span>    </span><span class="token" style="color:#ef3b7d">return</span><span> </span><span class="token" style="color:#a77afe">False</span><span>
</span>
<span></span><span class="token" style="color:#6f705e"># Is cipher1 a subset of cipher2?</span><span>
</span><span></span><span class="token" style="color:#ef3b7d">def</span><span> </span><span class="token function">cipher_is_subset</span><span class="token" style="color:#bebec5">(</span><span>cipher1</span><span class="token" style="color:#bebec5">:</span><span> </span><span class="token" style="color:#e6d06c">&#x27;Dict[str, str]&#x27;</span><span class="token" style="color:#bebec5">,</span><span> cipher2</span><span class="token" style="color:#bebec5">:</span><span> </span><span class="token" style="color:#e6d06c">&#x27;Dict[str, str]&#x27;</span><span class="token" style="color:#bebec5">)</span><span> </span><span class="token" style="color:#a77afe">-</span><span class="token" style="color:#a77afe">&gt;</span><span> </span><span class="token builtin">bool</span><span class="token" style="color:#bebec5">:</span><span>
</span><span>    </span><span class="token" style="color:#ef3b7d">return</span><span> </span><span class="token builtin">all</span><span class="token" style="color:#bebec5">(</span><span class="token" style="color:#bebec5">[</span><span>cipher2</span><span class="token" style="color:#bebec5">.</span><span>get</span><span class="token" style="color:#bebec5">(</span><span>k</span><span class="token" style="color:#bebec5">)</span><span> </span><span class="token" style="color:#a77afe">==</span><span> cipher1</span><span class="token" style="color:#bebec5">[</span><span>k</span><span class="token" style="color:#bebec5">]</span><span> </span><span class="token" style="color:#ef3b7d">for</span><span> k </span><span class="token" style="color:#ef3b7d">in</span><span> cipher1</span><span class="token" style="color:#bebec5">]</span><span class="token" style="color:#bebec5">)</span><span>
</span>
<!-- -->
<span></span><span class="token" style="color:#6f705e"># In[12]:</span><span>
</span>
<!-- -->
<span>cipher </span><span class="token" style="color:#a77afe">=</span><span> </span><span class="token" style="color:#bebec5">{</span><span>
</span><span>    </span><span class="token" style="color:#e6d06c">&#x27;a&#x27;</span><span class="token" style="color:#bebec5">:</span><span> </span><span class="token" style="color:#e6d06c">&#x27;g&#x27;</span><span class="token" style="color:#bebec5">,</span><span>
</span><span>    </span><span class="token" style="color:#e6d06c">&#x27;p&#x27;</span><span class="token" style="color:#bebec5">:</span><span> </span><span class="token" style="color:#e6d06c">&#x27;o&#x27;</span><span class="token" style="color:#bebec5">,</span><span>
</span><span>    </span><span class="token" style="color:#e6d06c">&#x27;f&#x27;</span><span class="token" style="color:#bebec5">:</span><span> </span><span class="token" style="color:#e6d06c">&#x27;d&#x27;</span><span class="token" style="color:#bebec5">,</span><span>
</span><span>    </span><span class="token" style="color:#e6d06c">&#x27;v&#x27;</span><span class="token" style="color:#bebec5">:</span><span> </span><span class="token" style="color:#e6d06c">&#x27;l&#x27;</span><span class="token" style="color:#bebec5">,</span><span>
</span><span>    </span><span class="token" style="color:#e6d06c">&#x27;i&#x27;</span><span class="token" style="color:#bebec5">:</span><span> </span><span class="token" style="color:#e6d06c">&#x27;u&#x27;</span><span class="token" style="color:#bebec5">,</span><span>
</span><span>    </span><span class="token" style="color:#e6d06c">&#x27;b&#x27;</span><span class="token" style="color:#bebec5">:</span><span> </span><span class="token" style="color:#e6d06c">&#x27;c&#x27;</span><span class="token" style="color:#bebec5">,</span><span>
</span><span></span><span class="token" style="color:#6f705e">#     &#x27;q&#x27;: &#x27;k&#x27;,</span><span>
</span><span></span><span class="token" style="color:#6f705e">#     &#x27;k&#x27;: &#x27;a&#x27;,</span><span>
</span><span></span><span class="token" style="color:#6f705e">#     &#x27;e&#x27;: &#x27;h&#x27;,</span><span>
</span><span></span><span class="token" style="color:#6f705e">#     &#x27;l&#x27;: &#x27;v&#x27;,</span><span>
</span><span></span><span class="token" style="color:#6f705e">#     &#x27;c&#x27;: &#x27;e&#x27;,</span><span>
</span><span></span><span class="token" style="color:#6f705e">#     &#x27;d&#x27;: &#x27;f&#x27;,</span><span>
</span><span></span><span class="token" style="color:#6f705e">#     &#x27;m&#x27;: &#x27;n&#x27;,</span><span>
</span><span></span><span class="token" style="color:#bebec5">}</span><span>
</span><span></span><span class="token" style="color:#ef3b7d">print</span><span class="token" style="color:#bebec5">(</span><span>MESSAGES</span><span class="token" style="color:#bebec5">[</span><span class="token" style="color:#a77afe">0</span><span class="token" style="color:#bebec5">]</span><span class="token" style="color:#bebec5">)</span><span>
</span><span></span><span class="token" style="color:#ef3b7d">print</span><span class="token" style="color:#bebec5">(</span><span>decode</span><span class="token" style="color:#bebec5">(</span><span>MESSAGES</span><span class="token" style="color:#bebec5">[</span><span class="token" style="color:#a77afe">0</span><span class="token" style="color:#bebec5">]</span><span class="token" style="color:#bebec5">,</span><span> cipher</span><span class="token" style="color:#bebec5">)</span><span class="token" style="color:#bebec5">)</span><span>
</span><span>scored_ciphers </span><span class="token" style="color:#a77afe">=</span><span> optimize_cipher</span><span class="token" style="color:#bebec5">(</span><span>MESSAGES</span><span class="token" style="color:#bebec5">[</span><span class="token" style="color:#a77afe">0</span><span class="token" style="color:#bebec5">]</span><span class="token" style="color:#bebec5">,</span><span> cipher</span><span class="token" style="color:#bebec5">)</span><span>
</span><span>pprint</span><span class="token" style="color:#bebec5">(</span><span class="token" style="color:#bebec5">[</span><span class="token" style="color:#bebec5">(</span><span>decode</span><span class="token" style="color:#bebec5">(</span><span>MESSAGES</span><span class="token" style="color:#bebec5">[</span><span class="token" style="color:#a77afe">0</span><span class="token" style="color:#bebec5">]</span><span class="token" style="color:#bebec5">,</span><span> x</span><span class="token" style="color:#bebec5">[</span><span class="token" style="color:#a77afe">0</span><span class="token" style="color:#bebec5">]</span><span class="token" style="color:#bebec5">)</span><span class="token" style="color:#bebec5">,</span><span> x</span><span class="token" style="color:#bebec5">[</span><span class="token" style="color:#a77afe">1</span><span class="token" style="color:#bebec5">]</span><span class="token" style="color:#bebec5">)</span><span> </span><span class="token" style="color:#ef3b7d">for</span><span> x </span><span class="token" style="color:#ef3b7d">in</span><span> scored_ciphers</span><span class="token" style="color:#bebec5">[</span><span class="token" style="color:#bebec5">:</span><span class="token" style="color:#a77afe">10</span><span class="token" style="color:#bebec5">]</span><span class="token" style="color:#bebec5">]</span><span class="token" style="color:#bebec5">)</span><span>
</span>
<!-- -->
<span></span><span class="token" style="color:#6f705e"># In[13]:</span><span>
</span>
<!-- -->
<span>cipher </span><span class="token" style="color:#a77afe">=</span><span> </span><span class="token" style="color:#bebec5">{</span><span>
</span><span>    </span><span class="token" style="color:#e6d06c">&#x27;x&#x27;</span><span class="token" style="color:#bebec5">:</span><span> </span><span class="token" style="color:#e6d06c">&#x27;a&#x27;</span><span class="token" style="color:#bebec5">,</span><span>
</span><span></span><span class="token" style="color:#bebec5">}</span><span>
</span>
<span></span><span class="token" style="color:#ef3b7d">print</span><span class="token" style="color:#bebec5">(</span><span>MESSAGES</span><span class="token" style="color:#bebec5">[</span><span class="token" style="color:#a77afe">1</span><span class="token" style="color:#bebec5">]</span><span class="token" style="color:#bebec5">)</span><span>
</span><span></span><span class="token" style="color:#ef3b7d">print</span><span class="token" style="color:#bebec5">(</span><span>decode</span><span class="token" style="color:#bebec5">(</span><span>MESSAGES</span><span class="token" style="color:#bebec5">[</span><span class="token" style="color:#a77afe">1</span><span class="token" style="color:#bebec5">]</span><span class="token" style="color:#bebec5">,</span><span> cipher</span><span class="token" style="color:#bebec5">)</span><span class="token" style="color:#bebec5">)</span><span>
</span><span>scored_ciphers </span><span class="token" style="color:#a77afe">=</span><span> optimize_cipher</span><span class="token" style="color:#bebec5">(</span><span>MESSAGES</span><span class="token" style="color:#bebec5">[</span><span class="token" style="color:#a77afe">1</span><span class="token" style="color:#bebec5">]</span><span class="token" style="color:#bebec5">,</span><span> cipher</span><span class="token" style="color:#bebec5">)</span><span>
</span><span>pprint</span><span class="token" style="color:#bebec5">(</span><span class="token" style="color:#bebec5">[</span><span class="token" style="color:#bebec5">(</span><span>decode</span><span class="token" style="color:#bebec5">(</span><span>MESSAGES</span><span class="token" style="color:#bebec5">[</span><span class="token" style="color:#a77afe">1</span><span class="token" style="color:#bebec5">]</span><span class="token" style="color:#bebec5">,</span><span> x</span><span class="token" style="color:#bebec5">[</span><span class="token" style="color:#a77afe">0</span><span class="token" style="color:#bebec5">]</span><span class="token" style="color:#bebec5">)</span><span class="token" style="color:#bebec5">,</span><span> x</span><span class="token" style="color:#bebec5">[</span><span class="token" style="color:#a77afe">1</span><span class="token" style="color:#bebec5">]</span><span class="token" style="color:#bebec5">)</span><span> </span><span class="token" style="color:#ef3b7d">for</span><span> x </span><span class="token" style="color:#ef3b7d">in</span><span> scored_ciphers</span><span class="token" style="color:#bebec5">[</span><span class="token" style="color:#bebec5">:</span><span class="token" style="color:#a77afe">10</span><span class="token" style="color:#bebec5">]</span><span class="token" style="color:#bebec5">]</span><span class="token" style="color:#bebec5">)</span><span>
</span>
<!-- -->
<span></span><span class="token" style="color:#6f705e"># In[14]:</span><span>
</span>
<!-- -->
<span>cipher </span><span class="token" style="color:#a77afe">=</span><span> </span><span class="token" style="color:#bebec5">{</span><span>
</span><span>    </span><span class="token" style="color:#e6d06c">&#x27;x&#x27;</span><span class="token" style="color:#bebec5">:</span><span> </span><span class="token" style="color:#e6d06c">&#x27;i&#x27;</span><span class="token" style="color:#bebec5">,</span><span>
</span><span></span><span class="token" style="color:#bebec5">}</span><span>
</span>
<span></span><span class="token" style="color:#ef3b7d">print</span><span class="token" style="color:#bebec5">(</span><span>MESSAGES</span><span class="token" style="color:#bebec5">[</span><span class="token" style="color:#a77afe">2</span><span class="token" style="color:#bebec5">]</span><span class="token" style="color:#bebec5">)</span><span>
</span><span></span><span class="token" style="color:#ef3b7d">print</span><span class="token" style="color:#bebec5">(</span><span>decode</span><span class="token" style="color:#bebec5">(</span><span>MESSAGES</span><span class="token" style="color:#bebec5">[</span><span class="token" style="color:#a77afe">2</span><span class="token" style="color:#bebec5">]</span><span class="token" style="color:#bebec5">,</span><span> cipher</span><span class="token" style="color:#bebec5">)</span><span class="token" style="color:#bebec5">)</span><span>
</span><span>scored_ciphers </span><span class="token" style="color:#a77afe">=</span><span> optimize_cipher</span><span class="token" style="color:#bebec5">(</span><span>MESSAGES</span><span class="token" style="color:#bebec5">[</span><span class="token" style="color:#a77afe">2</span><span class="token" style="color:#bebec5">]</span><span class="token" style="color:#bebec5">,</span><span> cipher</span><span class="token" style="color:#bebec5">)</span><span>
</span><span>decode</span><span class="token" style="color:#bebec5">(</span><span>MESSAGES</span><span class="token" style="color:#bebec5">[</span><span class="token" style="color:#a77afe">2</span><span class="token" style="color:#bebec5">]</span><span class="token" style="color:#bebec5">,</span><span> scored_ciphers</span><span class="token" style="color:#bebec5">[</span><span class="token" style="color:#a77afe">0</span><span class="token" style="color:#bebec5">]</span><span class="token" style="color:#bebec5">[</span><span class="token" style="color:#a77afe">0</span><span class="token" style="color:#bebec5">]</span><span class="token" style="color:#bebec5">)</span><span>
</span>
<!-- -->
<span></span><span class="token" style="color:#6f705e"># In[15]:</span><span>
</span>
<!-- -->
<span>cipher </span><span class="token" style="color:#a77afe">=</span><span> </span><span class="token" style="color:#bebec5">{</span><span>
</span><span>    </span><span class="token" style="color:#e6d06c">&#x27;g&#x27;</span><span class="token" style="color:#bebec5">:</span><span> </span><span class="token" style="color:#e6d06c">&#x27;a&#x27;</span><span class="token" style="color:#bebec5">,</span><span>
</span><span></span><span class="token" style="color:#bebec5">}</span><span>
</span>
<span></span><span class="token" style="color:#ef3b7d">print</span><span class="token" style="color:#bebec5">(</span><span>MESSAGES</span><span class="token" style="color:#bebec5">[</span><span class="token" style="color:#a77afe">3</span><span class="token" style="color:#bebec5">]</span><span class="token" style="color:#bebec5">)</span><span>
</span><span></span><span class="token" style="color:#ef3b7d">print</span><span class="token" style="color:#bebec5">(</span><span>decode</span><span class="token" style="color:#bebec5">(</span><span>MESSAGES</span><span class="token" style="color:#bebec5">[</span><span class="token" style="color:#a77afe">3</span><span class="token" style="color:#bebec5">]</span><span class="token" style="color:#bebec5">,</span><span> cipher</span><span class="token" style="color:#bebec5">)</span><span class="token" style="color:#bebec5">)</span><span>
</span><span>scored_ciphers </span><span class="token" style="color:#a77afe">=</span><span> optimize_cipher</span><span class="token" style="color:#bebec5">(</span><span>MESSAGES</span><span class="token" style="color:#bebec5">[</span><span class="token" style="color:#a77afe">3</span><span class="token" style="color:#bebec5">]</span><span class="token" style="color:#bebec5">,</span><span> cipher</span><span class="token" style="color:#bebec5">)</span><span>
</span><span>pprint</span><span class="token" style="color:#bebec5">(</span><span class="token" style="color:#bebec5">[</span><span class="token" style="color:#bebec5">(</span><span>decode</span><span class="token" style="color:#bebec5">(</span><span>MESSAGES</span><span class="token" style="color:#bebec5">[</span><span class="token" style="color:#a77afe">3</span><span class="token" style="color:#bebec5">]</span><span class="token" style="color:#bebec5">,</span><span> x</span><span class="token" style="color:#bebec5">[</span><span class="token" style="color:#a77afe">0</span><span class="token" style="color:#bebec5">]</span><span class="token" style="color:#bebec5">)</span><span class="token" style="color:#bebec5">,</span><span> x</span><span class="token" style="color:#bebec5">[</span><span class="token" style="color:#a77afe">1</span><span class="token" style="color:#bebec5">]</span><span class="token" style="color:#bebec5">)</span><span> </span><span class="token" style="color:#ef3b7d">for</span><span> x </span><span class="token" style="color:#ef3b7d">in</span><span> scored_ciphers</span><span class="token" style="color:#bebec5">[</span><span class="token" style="color:#bebec5">:</span><span class="token" style="color:#a77afe">5</span><span class="token" style="color:#bebec5">]</span><span class="token" style="color:#bebec5">]</span><span class="token" style="color:#bebec5">)</span><span>
</span>
<!-- -->
</code></pre></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"sketchData":{"id":"cryptograms","contentHtml":"\u003cstyle\u003e\n.cryptogram, .solution {\n  display: flex;\n  justify-content: center;\n}\n\n.cryptogram \u003e p, .solution \u003e p {\n    font-family: Courier, monospace;\n    margin: 0;\n}\n\n.solution \u003e p, .solution \u003e ul {\n  background-color: black;\n}\n\n.solution \u003e p:hover, .solution \u003e ul:hover {\n  background-color: inherit;\n}\n\u003c/style\u003e\n\u003cp\u003eFor Christmas my dad gave me a book of cryptograms. While I thought it would be fun to do these by hand,\nI thought it would also be fun to write a program to solve them.\u003c/p\u003e\n\u003ch2\u003eCryptograms\u003c/h2\u003e\n\u003cp\u003eEvery puzzle in the book uses a substitution cipher where every letter in the decoded space is represented\nby another letter in the encoded space. An example puzzle would be:\u003c/p\u003e\n\u003cdiv class=\"cryptogram\"\u003e\u003cp\u003eAPPF VIBQ KMF EKLC DIM!\u003c/p\u003e\u003c/div\u003e\n\u003cp\u003eYou can try solving it for yourself, or you can hover over the solution below.\u003c/p\u003e\n\u003cdiv class=\"solution\"\u003e\u003cp\u003eGOOD LUCK AND HAVE FUN!\u003c/p\u003e\u003c/div\u003e\n\u003cp\u003eThe cipher (the map from encoded to decoded characters) is what the program solves for. The cipher\nfor the above puzzle is:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003ea =\u003e g, p =\u003e o, f =\u003e d, v =\u003e l, i =\u003e u, b =\u003e c, q =\u003e k, k =\u003e a, e =\u003e h, l =\u003e v, c =\u003e e, d =\u003e f, m =\u003e n\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003eThe Algorithm\u003c/h2\u003e\n\u003cp\u003eThe main part of the program is a brute force search that recurses through all possible word combinations and looks for\nreasonable solutions. However just a naive brute force search would be very slow; it would have nothing to narrow down\nthe possibilities with.\u003c/p\u003e\n\u003cp\u003eThere needs to be another part of the program that makes some educated guesses. For this\nI used some simple intuitions about the English language that humans would use when solving a cryptogram (and that would\nbe easy to code). Examples of these intuitions include:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eA single letter word is almost always \"I\" or \"a\".\u003c/li\u003e\n\u003cli\u003eWords containing apostrophes are probably contractions, which there are a relatively small number of.\u003c/li\u003e\n\u003cli\u003eThe solution will probably follow an expected distribution of letters, starting letters, double letters, etc.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThe program uses a list of English words to solve the cipher. It works by guessing a word and doing a recursive\nsearch with the new cipher that comes from that word. For example, consider the earlier cryptogram and a partially\ncompleted solution:\u003c/p\u003e\n\u003cdiv class=\"cryptogram\"\u003e\u003cp\u003eAPPF VIBQ KMF EKLC DIM!\u003c/p\u003e\u003c/div\u003e\n\u003cdiv class=\"cryptogram\"\u003e\u003cp\u003e-OOD ---- --D ---- ---!\u003c/p\u003e\u003c/div\u003e\n\u003cp\u003eWe know all but the first letter of the first word, so we can \"guess and check\" by plugging in all words in the dictionary that match\nthe pattern \"-OOD\" (good, hood, wood, etc.). After plugging in a word we have a new cipher that includes the letter that\nwas previously encoded. We can recurse with this new cipher and try to guess other words until we find a solution (or not).\u003c/p\u003e\n\u003ch2\u003eIndexing\u003c/h2\u003e\n\u003cp\u003eTo do the pattern matching described above, I needed a quick way to look up words that match a certain pattern. I did\nthis by preprocessing the dictionary and keeping an index of character ngrams (I used 1, 2, and 3-grams).\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-py\"\u003e# Ngrams is a dictionary of the triple (ngram, len, i) mapped to a set of\n# words of length `len` where the character ngram `ngram` appears at index `i`.\n# By including the word length and index in the key we can narrow down word matches.\nngrams: 'Dict[Tuple[str, int, int], Set[str]]' = defaultdict(set)\n\n# words_by_length is a dictionary of length to set of words with that length.\nwords_by_length: 'Dict[int, Set[str]]' = defaultdict(set)\n\nfor word in dictionary:\n    words_by_length[len(word)].add(word)\n    for i in range(0, len(word)):\n        ngrams[(word[i], len(word), i)].add(word)\n        if i \u0026#x3C; len(word) - 1:\n            ngrams[(word[i:i+2], len(word), i)].add(word)\n        if i \u0026#x3C; len(word) - 2:\n            ngrams[(word[i:i+3], len(word), i)].add(word)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe code to do the pattern matching looks at each decoded ngram in the word, gets the set of words associated with that\nngram, and returns the intersection of the sets. For example, to pattern match the word \"ap-le\", we would would find the set of\nwords that have length 5 with \"ap\" appearing at index 0 and intersect it with the set of words of length 5 that have \"le\" appearing\nat index 3. If the word is completely encoded, the best we can do is return the set of words with the same length.\nCaching the results of this function is useful since it gets called with the same arguments many times.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-py\"\u003e@lru_cache(maxsize=None)\ndef find_words_matching_pattern(template: str) -\u003e 'Set[str]':\n    # Given a pattern, return words from dictionary that match. \"-\" is a wildcard.\n    # E.g. \"-ood\" -\u003e {\"good\", \"hood\", ...}\n    if template.isalpha():\n        return set([template])\n\n    ngram_word_matches: 'List[set]' = []\n    # look for decoded ngrams\n    for i in range(0, len(template)):\n        if template[i].isalpha():\n            ngram_word_matches.append(ngrams[(template[i], len(template), i)])\n        if i \u0026#x3C; len(template) - 1 and template[i:i+2].isalpha():\n            ngram_word_matches.append(ngrams[(template[i:i+2], len(template), i)])\n        if i \u0026#x3C; len(template) - 2 and template[i:i+3].isalpha():\n            ngram_word_matches.append(ngrams[(template[i:i+3], len(template), i)])\n\n    ngram_word_matches = [s for s in ngram_word_matches if len(s) \u003e 0]\n    if ngram_word_matches:\n        return reduce(lambda a, b: a \u0026#x26; b, ngram_word_matches)\n    else:\n        return words_by_length[len(template)]\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003eCipher Evaluation\u003c/h2\u003e\n\u003cp\u003eFor many cryptograms there are a number of possible solutions. I ran into this when I first coded up the search and got\nsome gibberish results that clearly weren't right but technically were solutions because they were valid ciphers and the\ndecoded message was composed of dictionary words.\u003c/p\u003e\n\u003cp\u003eWhen I first ran the algorithm on the puzzle \u003ccode\u003ePPF VIBQ KMF EKLC DIM!\u003c/code\u003e, I got solutions like:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\"wood luck ind aims fun\"\u003c/li\u003e\n\u003cli\u003e\"wood luck ind hist fun\"\u003c/li\u003e\n\u003cli\u003e\"wood luck ind tier fun\"\u003c/li\u003e\n\u003cli\u003eand so on...\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eI could probably have guessed the actual solution from this, but I wanted the program to be able to rank the solutions\nby how English-like they were.\u003c/p\u003e\n\u003cp\u003eMy first approach used word frequency (which was included in the \u003ca href=\"https://github.com/first20hours/google-10000-english\"\u003edictionary\u003c/a\u003e\nI was using). I thought scoring the solution by how common its words were would penalize solutions with the weird words I was seeing.\nThis didn't work great; the top results were:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\"good luck ind five run\"\u003c/li\u003e\n\u003cli\u003e\"good luck ind fits run\"\u003c/li\u003e\n\u003cli\u003e\"good luck ind five jun\"\u003c/li\u003e\n\u003cli\u003eand so on...\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eMy next idea was score the solutions by the frequency of their word bigrams. This was done pretty easily using a corpus from\nthe Python \u003ccode\u003enltk\u003c/code\u003e package, and put the correct solution much closer to the top:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\"good luck and have run\"\u003c/li\u003e\n\u003cli\u003e\"good luck and have sun\"\u003c/li\u003e\n\u003cli\u003e\"good luck and have fun\"\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003eMore Puzzles\u003c/h2\u003e\n\u003cp\u003eA quote from Sonia Sotomayor:\u003c/p\u003e\n\u003cdiv class=\"cryptogram\"\u003e\u003cp\u003eX WK DBKZ KBF NRXBM HYKTN CF: X WKB'N CFHVTQF CJVFPA YJ KNRFQV' FEUFONHNXKBV KQ PFN KNRFQV WFAXBF CJ ZKQNR.\u003c/p\u003e\u003c/div\u003e\n\u003cdiv class=\"solution\"\u003e\u003cp\u003eI do know one thing about me: I don't measure myself by others' expectations or let others define my worth.\u003c/p\u003e\u003c/div\u003e\n\u003cp\u003eIt turns out that the only guess the program needs to solve this one in a reasonable amount of time is what the single letter word is.\nAfter that guess is provided it runs in around 10 seconds.\u003c/p\u003e\n\u003c!-- blank lines in markdown remains a mystery... --\u003e\n\u003cdiv style=\"margin-top: 3em;\"\u003e\u003c/div\u003e\n\u003cp\u003eA quote from Gerald Ford:\u003c/p\u003e\n\u003cdiv class=\"cryptogram\"\u003e\u003cp\u003eG NQPBSDKBDX TUN BDQLNR XQ NUPB VQL BPBSVXRUDN VQL FGDX UJ G NQPBSDKBDX TUN BDQLNR XQ XGHB YSQK VQL BPBSVXRUDN VQL RGPB\u003c/p\u003e\u003c/div\u003e\n\u003cdiv class=\"solution\"\u003e\u003cp\u003eA government big enough to give you everything you want is a government big enough to take from you everything you have.\u003c/p\u003e\u003c/div\u003e\n\u003cp\u003eThis one has a number of solutions, the first four of which are:\u003c/p\u003e\n\u003cdiv class=\"solution\"\u003e\n  \u003cul\u003e\n    \u003cli\u003eA government big enough to give you everything you want is a government big enough to take from you everything you have.\u003c/li\u003e\n    \u003cli\u003eA government pig enough to give you everything you want is a government pig enough to take from you everything you have.\u003c/li\u003e\n    \u003cli\u003eA government dig enough to give you everything you want is a government dig enough to take from you everything you have.\u003c/li\u003e\n    \u003cli\u003eA government big enough to give you everything you cant is a government big enough to take from you everything you have.\u003c/li\u003e\n  \u003c/ul\u003e\n\u003c/div\u003e\n\u003cp\u003eThis shows quite nicely how the bigram ranking of the solutions put them in a logical order.\u003c/p\u003e\n","code":"#!/usr/bin/env python\n# coding: utf-8\n\n# In[1]:\n\n\nimport copy\nfrom collections import defaultdict\nfrom functools import lru_cache, reduce\nfrom pprint import pprint\nfrom time import time\n\nimport nltk\n\n\n# In[2]:\n\n\nwith open('../google-10000-english/google-10000-english.txt') as word_file:\n    dictionary = set(word_file.read().split())\n\n\n# In[3]:\n\n\nMESSAGES = [x.lower() for x in\n    [\n        'APPF VIBQ KMF EKLC DIM',\n        'ZCA LIZIQA PV KMZ X EPLZ PZ PV XK XSCPAUAFAKZ AUAQR EAKAQXZPMK CAYTV FXHA PZV MJK LIZIQA ZCPV PV ZCA AVVAKZPXY SCXYYAKEA ML ZCA TQAVAKZ',\n        \"X WK DBKZ KBF NRXBM HYKTN CF X WKBN CFHVTQF CJVFPA YJ KNRFQV FEUFONHNXKBV KQ PFN KNRFQV WFAXBF CJ ZKQNR\",\n        'G NQPBSDKBDX TUN BDQLNR XQ NUPB VQL BPBSVXRUDN VQL FGDX UJ G NQPBSDKBDX TUN BDQLNR XQ XGHB YSQK VQL BPBSVXRUDN VQL RGPB',\n    ]\n]\n\n\n# In[4]:\n\n\n# Ngrams are dictionaries of the triple (ngram, len, i) mapped to a set of\n# words of length `len` where the character ngram `ngram` appears at index `i`.\n# By including the word length and index in the key we can narrow down word matches later.\nngrams: 'Dict[Tuple[str, int, int], Set[str]]' = defaultdict(set)\n\n# words_by_length is a dictionary of word length to set of words\nwords_by_length: 'Dict[int, Set[str]]' = defaultdict(set)\n    \nwords_to_rank: 'Dict[str, int]' = defaultdict(lambda: 10_001)\n\nfor i, word in enumerate(dictionary):\n    words_by_length[len(word)].add(word)\n    words_to_rank[word] = i\n    for i in range(0, len(word)):\n        ngrams[(word[i], len(word), i)].add(word)\n        if i \u003c len(word) - 1:\n            ngrams[(word[i:i+2], len(word), i)].add(word)\n        if i \u003c len(word) - 2:\n            ngrams[(word[i:i+3], len(word), i)].add(word)\n\n\n# In[5]:\n\n\nwords = [w.lower() for w in nltk.corpus.gutenberg.words() if w.isalpha()]\nword_bigrams: 'Dict[Tuple[str, str], int]' = defaultdict(int)\nfor bigram in nltk.bigrams(words):\n    word_bigrams[bigram] += 1\n\n\n# In[6]:\n\n\n# what fraction of a candidate decoded message's words are found in the dictionary?\n#\n# `message` should be lowercase\n# contractions appear in dictionary without apostrophes e.g. \"wont\", \"shouldnt\"\ndef compute_fraction_in_dictionary(message: str):\n    message = ''.join([c for c in message if c.isalpha() or c in (' ', '-')])\n    words = message.split()\n    in_dict = [w for w in words if w in dictionary]\n    return len(in_dict) / len(words)\n\n\n# In[7]:\n\n\n# given a cipher and an encrypted message, decode the message\n# a cipher is a mapping between 'encrypted' and 'decrypted' characters\ndef decode(message: str, cipher: 'Dict[str, str]') -\u003e str:\n    result = ''\n    for char in message:\n        if not char.isalpha():\n            result += char\n        elif char in cipher:\n            result += cipher[char]\n        else:\n            result += '-'\n    return result\n\n\n# In[8]:\n\n\n# a cipher is valid if values don't repeat\ndef validate_cipher(cipher: 'Dict[str, str]') -\u003e bool:\n    return len(cipher.values()) == len(set(cipher.values()))\n\n\n# In[9]:\n\n\n# Higher score is better. Doesn't normalize for message length.\ndef score_cipher(message: str, cipher: 'Dict[str, str]') -\u003e float:\n    decoded_words = decode(message, cipher).split()\n\n    # by word popularity\n#     return -1 * sum([words_to_rank[w] for w in decoded_words])\n\n    # by bigram popularity\n    bigrams = nltk.bigrams(decoded_words)\n    return sum([word_bigrams[b] for b in bigrams])\n\n\n# In[10]:\n\n\n@lru_cache(maxsize=None)\ndef find_words_matching_pattern(template: str) -\u003e 'Set[str]':\n    # Given a pattern, return words from dictionary that match. \"-\" is a wildcard.\n    # E.g. \"-ood\" -\u003e {\"good\", \"hood\", ...}\n    if template.isalpha():\n        return set([template])\n\n    ngram_word_matches: 'List[set]' = []\n    # look for decoded ngrams\n    for i in range(0, len(template)):\n        if template[i].isalpha():\n            ngram_word_matches.append(ngrams[(template[i], len(template), i)])\n        if i \u003c len(template) - 1 and template[i:i+2].isalpha():\n            ngram_word_matches.append(ngrams[(template[i:i+2], len(template), i)])\n        if i \u003c len(template) - 2 and template[i:i+3].isalpha():\n            ngram_word_matches.append(ngrams[(template[i:i+3], len(template), i)])\n\n    ngram_word_matches = [s for s in ngram_word_matches if len(s) \u003e 0]\n    if ngram_word_matches:\n        return reduce(lambda a, b: a \u0026 b, ngram_word_matches)\n    else:\n        return words_by_length[len(template)]\n\n\n# In[11]:\n\n\ndef optimize_cipher(\n    message: str,\n    cipher: 'Dict[str, str]',\n) -\u003e 'List[Tuple[Dict[str, str], float]]':\n    # Given a message and an incomplete cipher, return a list of\n    # completed ciphers and their scores.\n    # Currently doesn't handle any punctuation (periods, apostrophes, etc.)\n    if not all([c.isalpha() or c == ' ' for c in message]):\n        raise ValueError(\"Message should only contain letters.\")\n    message = message.lower()\n\n    possible_new_ciphers = generate_possible_new_ciphers(\n        message.split(),\n        cipher,\n    )\n    scored_ciphers = [(cipher, score_cipher(message, cipher)) for cipher in possible_new_ciphers]\n    return sorted(scored_ciphers, key=lambda t: t[1], reverse=True)\n\ndef generate_possible_new_ciphers(\n    message_words: 'List[str]',\n    working_cipher: 'Dict[str, str]',\n) -\u003e 'List[Dict[str, str]]':\n    # For every word we found a bigram in we now have a set of possible decoded words.\n    # Each decoded word implies an expanded cipher using the letters that were previously\n    # encoded, so we return combinations of non-conflicting ciphers.\n    assert(validate_cipher(working_cipher))\n\n    result = []\n    possible_word_matches = find_words_matching_pattern(decode(message_words[0], working_cipher))\n    for word in possible_word_matches:\n        new_cipher = generate_new_cipher(message_words[0], word)\n        # a valid cipher will not always be generated: e.g. generate_new_cipher(\"abcd\", \"lulu\")\n        if validate_cipher(new_cipher) and not ciphers_conflict(working_cipher, new_cipher):\n            new_cipher.update(working_cipher)\n            if len(message_words) == 1:\n                result += [new_cipher]\n            else:\n                result += generate_possible_new_ciphers(\n                      message_words[1:],\n                      copy.copy(new_cipher),\n                  )\n    return result\n\n\ndef generate_new_cipher(original_word, decoded_word) -\u003e 'Dict[str, str]':\n    # should actually probably only generate parts of the cipher that are new\n    assert len(original_word) == len(decoded_word)\n    cipher = {}\n    for i in range(0, len(original_word)):\n        if decoded_word[i] != '-':\n            cipher[original_word[i]] = decoded_word[i]\n    return cipher\n\ndef invert_cipher(cipher: 'Dict[str, str]') -\u003e 'Dict[str, str]':\n    return {v: k for k, v in cipher.items()}\n\ndef ciphers_conflict(cipher1: 'Dict[str, str]', cipher2: 'Dict[str, str]') -\u003e bool:\n    assert(validate_cipher(cipher1) and validate_cipher(cipher2))\n    cipher1_inverse = invert_cipher(cipher1)\n    for k, v in cipher2.items():\n        if (k in cipher1 and v != cipher1[k] or\n            v in cipher1_inverse and k != cipher1_inverse[v]):\n            return True\n    return False\n\n# Is cipher1 a subset of cipher2?\ndef cipher_is_subset(cipher1: 'Dict[str, str]', cipher2: 'Dict[str, str]') -\u003e bool:\n    return all([cipher2.get(k) == cipher1[k] for k in cipher1])\n\n\n# In[12]:\n\n\ncipher = {\n    'a': 'g',\n    'p': 'o',\n    'f': 'd',\n    'v': 'l',\n    'i': 'u',\n    'b': 'c',\n#     'q': 'k',\n#     'k': 'a',\n#     'e': 'h',\n#     'l': 'v',\n#     'c': 'e',\n#     'd': 'f',\n#     'm': 'n',\n}\nprint(MESSAGES[0])\nprint(decode(MESSAGES[0], cipher))\nscored_ciphers = optimize_cipher(MESSAGES[0], cipher)\npprint([(decode(MESSAGES[0], x[0]), x[1]) for x in scored_ciphers[:10]])\n\n\n# In[13]:\n\n\ncipher = {\n    'x': 'a',\n}\n\nprint(MESSAGES[1])\nprint(decode(MESSAGES[1], cipher))\nscored_ciphers = optimize_cipher(MESSAGES[1], cipher)\npprint([(decode(MESSAGES[1], x[0]), x[1]) for x in scored_ciphers[:10]])\n\n\n# In[14]:\n\n\ncipher = {\n    'x': 'i',\n}\n\nprint(MESSAGES[2])\nprint(decode(MESSAGES[2], cipher))\nscored_ciphers = optimize_cipher(MESSAGES[2], cipher)\ndecode(MESSAGES[2], scored_ciphers[0][0])\n\n\n# In[15]:\n\n\ncipher = {\n    'g': 'a',\n}\n\nprint(MESSAGES[3])\nprint(decode(MESSAGES[3], cipher))\nscored_ciphers = optimize_cipher(MESSAGES[3], cipher)\npprint([(decode(MESSAGES[3], x[0]), x[1]) for x in scored_ciphers[:5]])\n\n","codeFilename":"cryptograms.py","hasReactComponent":false,"pinned":false,"title":"Solving Cryptograms","date":"2021-01-02","languages":["python"]}},"__N_SSG":true},"page":"/sketches/[id]","query":{"id":"cryptograms"},"buildId":"CwgKdIK8AqblozSXCPnVa","nextExport":false,"isFallback":false,"gsp":true}</script><script nomodule="" src="/_next/static/chunks/polyfills-dccdf6a71d009d028b56.js"></script><script src="/_next/static/chunks/main-70acde2203962b3dc5d4.js" async=""></script><script src="/_next/static/chunks/webpack-50d38cb9c3dd5374e2a2.js" async=""></script><script src="/_next/static/chunks/framework.0a4392dc64510ab178c1.js" async=""></script><script src="/_next/static/chunks/commons.6d3bde474c27debf47e2.js" async=""></script><script src="/_next/static/chunks/pages/_app-1018bc17b6123053b3bf.js" async=""></script><script src="/_next/static/chunks/fe66c3e56503ac18952228a608ca3464c3766972.02ceb7646fd5a00b4908.js" async=""></script><script src="/_next/static/chunks/pages/sketches/%5Bid%5D-efff1a0c2435fd0b2b31.js" async=""></script><script src="/_next/static/CwgKdIK8AqblozSXCPnVa/_buildManifest.js" async=""></script><script src="/_next/static/CwgKdIK8AqblozSXCPnVa/_ssgManifest.js" async=""></script></body></html>