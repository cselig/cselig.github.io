{
    "componentChunkName": "component---src-templates-post-js",
    "path": "/blog/cryptograms",
    "result": {"data":{"mdx":{"body":"var _excluded = [\"components\"];\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n/* @jsxRuntime classic */\n/* @jsx mdx */\n\nvar _frontmatter = {\n  \"title\": \"Solving Cryptograms\",\n  \"date\": \"2021-01-02T00:00:00.000Z\",\n  \"excerpt\": \"Xucmfgma dglc epiyx zp xpvlc k uinnvc zekz xepivf zkqc dglc ogmizcx.\",\n  \"topic\": \"programming\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n    props = _objectWithoutProperties(_ref, _excluded);\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"For Christmas my dad gave me a book of cryptograms. While I thought it would be fun to do these by hand,\\nI thought it would also be fun to write a program to solve them.\"), mdx(\"h2\", null, \"Cryptograms\"), mdx(\"p\", null, \"Every puzzle in the book uses a substitution cipher where every letter in the decoded space is represented\\nby another letter in the encoded space. An example puzzle would be:\"), mdx(\"div\", {\n    className: \"cryptogram\"\n  }, mdx(\"p\", null, \"APPF VIBQ KMF EKLC DIM!\")), mdx(\"p\", null, \"You can try solving it for yourself, or you can hover over the solution below.\"), mdx(\"div\", {\n    className: \"solution\"\n  }, mdx(\"p\", null, \"GOOD LUCK AND HAVE FUN!\")), mdx(\"p\", null, \"The cipher (the map from encoded to decoded characters) is what the program solves for.\"), mdx(\"h2\", null, \"The Algorithm\"), mdx(\"p\", null, \"The main part of the program is a brute force search that recurses through all possible word combinations and looks for\\nreasonable solutions. However just a naive brute force search would be very slow; it would have nothing to narrow down\\nthe possibilities with.\"), mdx(\"p\", null, \"There needs to be another part of the program that makes some educated guesses. For this\\nI used some simple intuitions about the English language that humans would use when solving a cryptogram (and that would\\nbe easy to code). Examples of these intuitions include:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"A single letter word is almost always \\\"I\\\" or \\\"a\\\".\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Words containing apostrophes are probably contractions, which there are a relatively small number of.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"The solution will probably follow an expected distribution of letters, starting letters, double letters, etc.\")), mdx(\"p\", null, \"The program uses a list of English words to solve the cipher. It works by guessing a word and doing a recursive\\nsearch with the new cipher that comes from that word. For example, consider the earlier cryptogram and a partially\\ncompleted solution:\"), mdx(\"div\", {\n    className: \"cryptogram\"\n  }, mdx(\"p\", null, \"APPF VIBQ KMF EKLC DIM!\")), mdx(\"div\", {\n    className: \"cryptogram\"\n  }, mdx(\"p\", null, \"-OOD ---- --D ---- ---!\")), mdx(\"p\", null, \"We know all but the first letter of the first word, so we can \\\"guess and check\\\" by plugging in all words in the dictionary that match\\nthe pattern \\\"-OOD\\\" (good, hood, wood, etc.). After plugging in a word we have a new cipher that includes the letter that\\nwas previously encoded. We can recurse with this new cipher and try to guess other words until we find a solution (or not).\"), mdx(\"h2\", null, \"Indexing\"), mdx(\"p\", null, \"To do the pattern matching described above, I needed a quick way to look up words that match a certain pattern. I did\\nthis by preprocessing the dictionary and keeping an index of character ngrams (I used 1, 2, and 3-grams).\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-py\"\n  }, \"# Ngrams is a dictionary of the triple (ngram, len, i) mapped to a set of\\n# words of length `len` where the character ngram `ngram` appears at index `i`.\\n# By including the word length and index in the key we can narrow down word matches.\\nngrams: 'Dict[Tuple[str, int, int], Set[str]]' = defaultdict(set)\\n\\n# words_by_length is a dictionary of length to set of words with that length.\\nwords_by_length: 'Dict[int, Set[str]]' = defaultdict(set)\\n\\nfor word in dictionary:\\n    words_by_length[len(word)].add(word)\\n    for i in range(0, len(word)):\\n        ngrams[(word[i], len(word), i)].add(word)\\n        if i < len(word) - 1:\\n            ngrams[(word[i:i+2], len(word), i)].add(word)\\n        if i < len(word) - 2:\\n            ngrams[(word[i:i+3], len(word), i)].add(word)\\n\")), mdx(\"p\", null, \"The code to do the pattern matching looks at each decoded ngram in the word, gets the set of words associated with that\\nngram, and returns the intersection of the sets. For example, to pattern match the word \\\"ap-le\\\", we would would find the set of\\nwords that have length 5 with \\\"ap\\\" appearing at index 0 and intersect it with the set of words of length 5 that have \\\"le\\\" appearing\\nat index 3. If the word is completely encoded, the best we can do is return the set of words with the same length.\\nCaching the results of this function is useful since it gets called with the same arguments many times.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-py\"\n  }, \"@lru_cache(maxsize=None)\\ndef find_words_matching_pattern(template: str) -> 'Set[str]':\\n    # Given a pattern, return words from dictionary that match. \\\"-\\\" is a wildcard.\\n    # E.g. \\\"-ood\\\" -> {\\\"good\\\", \\\"hood\\\", ...}\\n    if template.isalpha():\\n        return set([template])\\n\\n    ngram_word_matches: 'List[set]' = []\\n    # look for decoded ngrams\\n    for i in range(0, len(template)):\\n        if template[i].isalpha():\\n            ngram_word_matches.append(ngrams[(template[i], len(template), i)])\\n        if i < len(template) - 1 and template[i:i+2].isalpha():\\n            ngram_word_matches.append(ngrams[(template[i:i+2], len(template), i)])\\n        if i < len(template) - 2 and template[i:i+3].isalpha():\\n            ngram_word_matches.append(ngrams[(template[i:i+3], len(template), i)])\\n\\n    ngram_word_matches = [s for s in ngram_word_matches if len(s) > 0]\\n    if ngram_word_matches:\\n        return reduce(lambda a, b: a & b, ngram_word_matches)\\n    else:\\n        return words_by_length[len(template)]\\n\")), mdx(\"h2\", null, \"Cipher Evaluation\"), mdx(\"p\", null, \"For many cryptograms there are a number of possible solutions. I ran into this when I first coded up the search and got\\nsome gibberish results that clearly weren't right but technically were solutions because they were valid ciphers and the\\ndecoded message was composed of dictionary words.\"), mdx(\"p\", null, \"When I first ran the algorithm on the puzzle \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"PPF VIBQ KMF EKLC DIM!\"), \", I got solutions like:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\\\"wood luck ind aims fun\\\"\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\\\"wood luck ind hist fun\\\"\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\\\"wood luck ind tier fun\\\"\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"and so on...\")), mdx(\"p\", null, \"I could probably have guessed the actual solution from this, but I wanted the program to be able to rank the solutions\\nby how English-like they were.\"), mdx(\"p\", null, \"My first approach used word frequency (which was included in the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/first20hours/google-10000-english\"\n  }, \"dictionary\"), \"\\nI was using). I thought scoring the solution by how common its words were would penalize solutions with the weird words I was seeing.\\nThis didn't work great; the top results were:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\\\"good luck ind five run\\\"\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\\\"good luck ind fits run\\\"\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\\\"good luck ind five jun\\\"\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"and so on...\")), mdx(\"p\", null, \"My next idea was score the solutions by the frequency of their word bigrams. This was done pretty easily using a corpus from\\nthe Python \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"nltk\"), \" package, and put the correct solution much closer to the top:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\\\"good luck and have run\\\"\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\\\"good luck and have sun\\\"\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\\\"good luck and have fun\\\"\")), mdx(\"p\", null, \"The completed code is \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/cselig/puzzles/blob/main/notebooks/cryptograms.ipynb\"\n  }, \"here\"), \".\"), mdx(\"h2\", null, \"More Puzzles\"), mdx(\"p\", null, \"A quote from Sonia Sotomayor:\"), mdx(\"div\", {\n    className: \"cryptogram\"\n  }, mdx(\"p\", null, \"X WK DBKZ KBF NRXBM HYKTN CF: X WKB'N CFHVTQF CJVFPA YJ KNRFQV' FEUFONHNXKBV KQ PFN KNRFQV WFAXBF CJ ZKQNR.\")), mdx(\"div\", {\n    className: \"solution\"\n  }, mdx(\"p\", null, \"I do know one thing about me: I don't measure myself by others' expectations or let others define my worth.\")), mdx(\"p\", null, \"It turns out that the only guess the program needs to solve this one in a reasonable amount of time is what the single letter word is.\\nAfter that guess is provided it runs in around 10 seconds.\"), mdx(\"div\", {\n    style: {\n      \"marginTop\": \"3em\"\n    }\n  }), mdx(\"p\", null, \"A quote from Gerald Ford:\"), mdx(\"div\", {\n    className: \"cryptogram\"\n  }, mdx(\"p\", null, \"G NQPBSDKBDX TUN BDQLNR XQ NUPB VQL BPBSVXRUDN VQL FGDX UJ G NQPBSDKBDX TUN BDQLNR XQ XGHB YSQK VQL BPBSVXRUDN VQL RGPB\")), mdx(\"div\", {\n    className: \"solution\"\n  }, mdx(\"p\", null, \"A government big enough to give you everything you want is a government big enough to take from you everything you have.\")), mdx(\"p\", null, \"This one has a number of solutions, the first four of which are:\"), mdx(\"div\", {\n    className: \"solution\"\n  }, mdx(\"ul\", null, mdx(\"li\", null, \"A government big enough to give you everything you want is a government big enough to take from you everything you have.\"), mdx(\"li\", null, \"A government pig enough to give you everything you want is a government pig enough to take from you everything you have.\"), mdx(\"li\", null, \"A government dig enough to give you everything you want is a government dig enough to take from you everything you have.\"), mdx(\"li\", null, \"A government big enough to give you everything you cant is a government big enough to take from you everything you have.\"))), mdx(\"p\", null, \"This shows quite nicely how the bigram ranking of the solutions put them in a logical order.\"));\n}\n;\nMDXContent.isMDXComponent = true;","frontmatter":{"title":"Solving Cryptograms","draft":null},"fields":{"slug":"cryptograms"}}},"pageContext":{"slug":"cryptograms"}},
    "staticQueryHashes": ["2999498863"]}