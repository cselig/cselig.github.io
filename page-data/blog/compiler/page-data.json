{
    "componentChunkName": "component---src-templates-post-js",
    "path": "/blog/compiler",
    "result": {"data":{"mdx":{"body":"var _excluded = [\"components\"];\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n/* @jsxRuntime classic */\n/* @jsx mdx */\n\nvar _frontmatter = {\n  \"title\": \"Visual Compiler\",\n  \"date\": \"2021-12-09T00:00:00.000Z\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n    props = _objectWithoutProperties(_ref, _excluded);\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"After taking \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://www.edx.org/course/compilers\"\n  }, \"this\"), \" online compilers class, I thought it would be\\nfun to build compiler for a simple language that displays output of some intermediate compiler phases.\"), mdx(\"h2\", null, \"A Simple Calculator Language\"), mdx(\"p\", null, \"The language I chose to implement is a simple one that only supports functions, if-then-else expressions,\\naddition, subtraction, and integer constants. The body of each function is a single expression.\"), mdx(\"h2\", null, \"Parsing\"), mdx(\"p\", null, \"The first step of the compiler is lexing and parsing which I implemented with \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://gerhobbelt.github.io/jison/docs/\"\n  }, \"Jison\"), \".\\nJison and similar tools like Bison and Yacc require you to specify the grammar of your language.\"), mdx(\"p\", null, \"A specification for the calculator language would look something like:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"A \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"program\"), \" is made of one or more \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"functions\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Each \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"function\"), \" may have parameters, and has a single \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"expression\"), \" for the body\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"An \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"expression\"), \" can be \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"addition\"), \", subtraction, if-then-else, function invocation, parameter ID, or a constant.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"An \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"addition expression\"), \" has left-hand and right-hand side expressions.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"And so on...\")), mdx(\"p\", null, \"Jison takes this specification and returns a parse tree.\"), mdx(\"h2\", null, \"Static Analysis\"), mdx(\"p\", null, \"Static analysis is run over the parse tree to ensure that the program follows some rules of the language.\"), mdx(\"p\", null, \"The rules are:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"There should be one function named \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"Main\"), \" that takes no parameters\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Function names should be unique\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Parameter names for each function should be unique\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Functions should be invoked with the correct number of arguments\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"All variables in a function should refer to one of the function's parameters\")), mdx(\"p\", null, \"You can click on the example \\\"Static Analysis Errors\\\" below to see a program that breaks some of these rules.\"), mdx(\"h2\", null, \"Code Generation\"), mdx(\"p\", null, \"Code generation is the final step of this compiler and runs via a recursive descent of the parse tree.\"), mdx(\"p\", null, \"Code generation targets the simple instruction set of \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://en.wikipedia.org/wiki/MIPS_architecture\"\n  }, \"MIPS\"), \".\\nThe following registers are used:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"$a0\"), \": the accumulator\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"$t1\"), \": for temporary results\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"$sp\"), \": the stack pointer\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Address of next unallocated location on stack kept here\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"$fp\"), \": the frame pointer\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Pointer to currently active stack frame\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"$ra\"), \": the return address\")), mdx(\"p\", null, \"Evaluating an expression will always leave the stack unchanged and the result of the expression in\\n\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"$a0\"), \", the accumulator register.\"), mdx(\"p\", null, \"All code can be found \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/cselig/cselig.github.io/tree/develop/content/blog/compiler\"\n  }, \"here\"), \".\"), mdx(RootUIContainer, {\n    mdxType: \"RootUIContainer\"\n  }));\n}\n;\nMDXContent.isMDXComponent = true;","frontmatter":{"title":"Visual Compiler","draft":null},"fields":{"slug":"compiler"}}},"pageContext":{"slug":"compiler"}},
    "staticQueryHashes": ["2999498863"]}