{"pageProps":{"sketchData":{"id":"ski_graph","contentHtml":"<p>I recently went skiing at Heavenly resort in South Lake Tahoe, and the process of studying the trail map and picking\nout routes got me thinking about how a ski resort is basically a big directed graph (assuming you stay \"on-piste\").</p>\n<p>This inspired me to make a little widget that would find shortest paths between two points in the resort. The result\nis a simplified version of Heavenly that doesn't include the parts that were closed when I was there and\nalso doesn't include advanced terrain that I can't ski down (yet). The grey edges are the chairlifts, and the other edges\nare the runs color-coded by level.</p>\n<p>To find a path, click on a start and end node.</p>\n","code":"import React from 'react'\nimport * as d3 from 'd3'\n\nimport * as graphUtils from '../../lib/graph_utils.js'\n\nimport nodesData from '../../data/graphs/heavenly/nodes.json'\nimport edgesData from '../../data/graphs/heavenly/edges.json'\n\nimport styles from '../../styles/sketches/ski_graph.module.scss'\n\nconst SVG_WIDTH = 500,\n      SVG_HEIGHT = 500\n\nconst colorMap = {\n  \"blue\": \"#1E88E5\",\n  \"green\": \"#229954\"\n}\n\nconst delay = 500\nconst fadeInText  = () => d3.select(\"#ski-graph .text\").transition().duration(delay).style(\"opacity\", 1)\nconst fadeOutText = () => d3.select(\"#ski-graph .text\").transition().duration(delay).style(\"opacity\", 0)\n\n// moving these functions out of graphUtils for now.\nfunction makeAdjacencyList(edges, nodes) {\n  let adjacencyList = new Map()\n  for (const {start, end} of edges) {\n    if (adjacencyList.has(start)) {\n      adjacencyList.get(start).push(end)\n    } else {\n      adjacencyList.set(start, [end])\n    }\n  }\n  for (let i = 0; i < nodes.length; i++) {\n    if (!adjacencyList.has(i)) adjacencyList.set(i, [])\n  }\n  return adjacencyList\n}\n\n// takes start and end nodes and returns [path_exists, path]\nfunction bfs(start, end, edges, nodes) {\n  if (start === end) return [true, [start]]\n\n  const adjacencyList = makeAdjacencyList(edges, nodes)\n\n  let q = [[start]]\n  let seen = new Set([start])\n\n  while (!(q.length === 0)) {\n    const q_length = q.length\n    for (let i = 0; i < q_length; i++) {\n      const path = q[i]\n      const curr_node = path[path.length - 1]\n      for (const neighbor of adjacencyList.get(curr_node)) {\n        if (neighbor === end) {\n          return [true, path.concat(neighbor)]\n        }\n        if (!seen.has(neighbor)) {\n          seen.add(neighbor)\n          q.push(path.concat(neighbor))\n        }\n      }\n    }\n    q = q.slice(q_length)\n  }\n  return [false, []]\n}\n\nfunction highlightPath(path, onAnimationFinish = () => {}, transitionLength = 500, delayUnit = 100) {\n  d3.selectAll(`g.${styles.node}, g.edge`).transition().duration(300).style(\"opacity\", 0.3)\n\n  d3.selectAll(`g.${styles.node}`)\n    .each((_, i, nodes) => {\n      if (path.includes(i)) {\n        d3.select(nodes[i])\n          .transition()\n          .duration(transitionLength)\n          .delay(path.indexOf(i) * 2 * delayUnit + 3 * delayUnit)\n            .style(\"opacity\", 1)\n      }\n    })\n\n  d3.selectAll(\"g.edge\")\n    .each((_, i, nodes) => {\n      d3.select(nodes[i])\n        .transition()\n        .duration(transitionLength)\n        .delay((d) => {\n          for (let j = 0; j < path.length - 1; j++) {\n            if (path[j] === d.start && path[j + 1] === d.end) {\n              return (j * 2 + 1)* delayUnit + 3 * delayUnit\n            }\n          }\n        })\n          .style(\"opacity\", 1)\n    })\n\n  const animationLength = (path.length * 2 + 3) * delayUnit\n  setTimeout(onAnimationFinish, animationLength)\n}\n\nclass SkiGraph extends React.Component {\n  constructor(props) {\n    super(props)\n    this.state = {\n      start: null,\n      end: null,\n    }\n  }\n\n  render() {\n    const reset = () => {\n      this.setState({start: null, end: null})\n      d3.selectAll(`g.${styles.node} circle`).classed(styles.selected, false)\n      d3.selectAll(`g.${styles.node}`).transition().duration(500).style(\"opacity\", 1)\n      d3.selectAll(\"g.edge\").transition().duration(500).style(\"opacity\", 1)\n    }\n\n    let displayText\n    let onTextClick\n    let textClass = styles.text\n    if (this.state.start === null) {\n      displayText = \"Pick start\"\n    } else if (this.state.end === null) {\n      displayText = \"Pick end\"\n    } else {\n      // on this graph there should be a path between every pair of nodes\n      const [_, path] = bfs(this.state.start, this.state.end, edgesData, nodesData)\n      highlightPath(path, () => setTimeout(fadeInText, 500))\n      displayText = \"Reset\"\n      onTextClick = reset\n      textClass += \" \" + styles.reset_button\n    }\n\n    return (\n      <div id=\"ski-graph\" className={styles.ski_graph}>\n        <p\n          onClick={onTextClick}\n          className={textClass}\n        >{displayText}</p>\n\n        <svg width={SVG_WIDTH} height={SVG_HEIGHT}></svg>\n      </div>\n    )\n  }\n\n  componentDidMount() {\n    let svg = d3.select(\"#ski-graph svg\")\n    graphUtils.setUpSvg(svg)\n\n    const scaledNodes = graphUtils.scaleNodeData(nodesData, SVG_WIDTH, SVG_HEIGHT)\n\n    const onNodeClick = (e, d) => {\n      if (this.state.start != null && this.state.end != null) return\n\n      const i = scaledNodes.indexOf(d)\n\n      // this is a pretty clumsy way to do animations but it's simple enough in this case.\n      if (this.state.start == null) {\n        fadeOutText()\n        setTimeout(\n          () => {\n            this.setState({start: i})\n            fadeInText()\n          },\n          delay\n        )\n      } else if (this.state.end == null) {\n        fadeOutText()\n        setTimeout(\n          // fading the text back in is handled in a callback after the animation is finished\n          () => this.setState({end: i}),\n          delay\n        )\n      }\n      d3.select(e.target).classed(styles.selected, true)\n    }\n\n    const nodeOpts = {\n      onClick: onNodeClick,\n      className: styles.node,\n    }\n\n    const edgeOpts = {\n      strokeFn: (d) => d.level ? colorMap[d.level] : \"grey\"\n    }\n\n    graphUtils.renderEdgesD3({svg: svg, edgeData: edgesData, nodeData: scaledNodes, directed: true, opts: edgeOpts})\n    graphUtils.renderNodesD3({svg: svg, nodeData: scaledNodes, opts: nodeOpts})\n  }\n}\n\n// Downstream code is set up to display only functional components.\nexport default function SkiGraphFn() { return <SkiGraph /> }\n","codeFilename":"ski_graph.jsx","hasReactComponent":true,"pinned":false,"title":"Ski Graphs","date":"2021-01-28","languages":["js","d3"]}},"__N_SSG":true}